# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAlbum {
  _avg: AlbumAvgAggregate
  _count: AlbumCountAggregate
  _max: AlbumMaxAggregate
  _min: AlbumMinAggregate
  _sum: AlbumSumAggregate
}

type AggregateArtist {
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
}

type AggregateCustomer {
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
}

type AggregateEmployee {
  _avg: EmployeeAvgAggregate
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
  _sum: EmployeeSumAggregate
}

type AggregateGenre {
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
}

type AggregateInvoice {
  _avg: InvoiceAvgAggregate
  _count: InvoiceCountAggregate
  _max: InvoiceMaxAggregate
  _min: InvoiceMinAggregate
  _sum: InvoiceSumAggregate
}

type AggregateInvoiceLine {
  _avg: InvoiceLineAvgAggregate
  _count: InvoiceLineCountAggregate
  _max: InvoiceLineMaxAggregate
  _min: InvoiceLineMinAggregate
  _sum: InvoiceLineSumAggregate
}

type AggregateMediaType {
  _avg: MediaTypeAvgAggregate
  _count: MediaTypeCountAggregate
  _max: MediaTypeMaxAggregate
  _min: MediaTypeMinAggregate
  _sum: MediaTypeSumAggregate
}

type AggregatePlaylist {
  _avg: PlaylistAvgAggregate
  _count: PlaylistCountAggregate
  _max: PlaylistMaxAggregate
  _min: PlaylistMinAggregate
  _sum: PlaylistSumAggregate
}

type AggregatePlaylistTrack {
  _avg: PlaylistTrackAvgAggregate
  _count: PlaylistTrackCountAggregate
  _max: PlaylistTrackMaxAggregate
  _min: PlaylistTrackMinAggregate
  _sum: PlaylistTrackSumAggregate
}

type AggregateTrack {
  _avg: TrackAvgAggregate
  _count: TrackCountAggregate
  _max: TrackMaxAggregate
  _min: TrackMinAggregate
  _sum: TrackSumAggregate
}

type Album {
  AlbumId: Int!
  Artist: Artist!
  ArtistId: Int!
  Title: String!
  Track(cursor: TrackWhereUniqueInput, distinct: [TrackScalarFieldEnum!], orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): [Track!]!
  _count: AlbumCount
}

type AlbumAvgAggregate {
  AlbumId: Float
  ArtistId: Float
}

input AlbumAvgOrderByAggregateInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
}

type AlbumCount {
  Track: Int!
}

type AlbumCountAggregate {
  AlbumId: Int!
  ArtistId: Int!
  Title: Int!
  _all: Int!
}

input AlbumCountOrderByAggregateInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
  Title: SortOrder
}

input AlbumCreateInput {
  AlbumId: Int!
  Artist: ArtistCreateNestedOneWithoutAlbumInput!
  Title: String!
  Track: TrackCreateNestedManyWithoutAlbumInput
}

input AlbumCreateManyArtistInput {
  AlbumId: Int!
  Title: String!
}

input AlbumCreateManyArtistInputEnvelope {
  data: [AlbumCreateManyArtistInput!]!
  skipDuplicates: Boolean
}

input AlbumCreateManyInput {
  AlbumId: Int!
  ArtistId: Int!
  Title: String!
}

input AlbumCreateNestedManyWithoutArtistInput {
  connect: [AlbumWhereUniqueInput!]
  connectOrCreate: [AlbumCreateOrConnectWithoutArtistInput!]
  create: [AlbumCreateWithoutArtistInput!]
  createMany: AlbumCreateManyArtistInputEnvelope
}

input AlbumCreateNestedOneWithoutTrackInput {
  connect: AlbumWhereUniqueInput
  connectOrCreate: AlbumCreateOrConnectWithoutTrackInput
  create: AlbumCreateWithoutTrackInput
}

input AlbumCreateOrConnectWithoutArtistInput {
  create: AlbumCreateWithoutArtistInput!
  where: AlbumWhereUniqueInput!
}

input AlbumCreateOrConnectWithoutTrackInput {
  create: AlbumCreateWithoutTrackInput!
  where: AlbumWhereUniqueInput!
}

input AlbumCreateWithoutArtistInput {
  AlbumId: Int!
  Title: String!
  Track: TrackCreateNestedManyWithoutAlbumInput
}

input AlbumCreateWithoutTrackInput {
  AlbumId: Int!
  Artist: ArtistCreateNestedOneWithoutAlbumInput!
  Title: String!
}

type AlbumGroupBy {
  AlbumId: Int!
  ArtistId: Int!
  Title: String!
  _avg: AlbumAvgAggregate
  _count: AlbumCountAggregate
  _max: AlbumMaxAggregate
  _min: AlbumMinAggregate
  _sum: AlbumSumAggregate
}

input AlbumListRelationFilter {
  every: AlbumWhereInput
  none: AlbumWhereInput
  some: AlbumWhereInput
}

type AlbumMaxAggregate {
  AlbumId: Int
  ArtistId: Int
  Title: String
}

input AlbumMaxOrderByAggregateInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
  Title: SortOrder
}

type AlbumMinAggregate {
  AlbumId: Int
  ArtistId: Int
  Title: String
}

input AlbumMinOrderByAggregateInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
  Title: SortOrder
}

input AlbumOrderByRelationAggregateInput {
  _count: SortOrder
}

input AlbumOrderByWithAggregationInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
  Title: SortOrder
  _avg: AlbumAvgOrderByAggregateInput
  _count: AlbumCountOrderByAggregateInput
  _max: AlbumMaxOrderByAggregateInput
  _min: AlbumMinOrderByAggregateInput
  _sum: AlbumSumOrderByAggregateInput
}

input AlbumOrderByWithRelationInput {
  AlbumId: SortOrder
  Artist: ArtistOrderByWithRelationInput
  ArtistId: SortOrder
  Title: SortOrder
  Track: TrackOrderByRelationAggregateInput
}

input AlbumRelationFilter {
  is: AlbumWhereInput
  isNot: AlbumWhereInput
}

enum AlbumScalarFieldEnum {
  AlbumId
  ArtistId
  Title
}

input AlbumScalarWhereInput {
  AND: [AlbumScalarWhereInput!]
  AlbumId: IntFilter
  ArtistId: IntFilter
  NOT: [AlbumScalarWhereInput!]
  OR: [AlbumScalarWhereInput!]
  Title: StringFilter
}

input AlbumScalarWhereWithAggregatesInput {
  AND: [AlbumScalarWhereWithAggregatesInput!]
  AlbumId: IntWithAggregatesFilter
  ArtistId: IntWithAggregatesFilter
  NOT: [AlbumScalarWhereWithAggregatesInput!]
  OR: [AlbumScalarWhereWithAggregatesInput!]
  Title: StringWithAggregatesFilter
}

type AlbumSumAggregate {
  AlbumId: Int
  ArtistId: Int
}

input AlbumSumOrderByAggregateInput {
  AlbumId: SortOrder
  ArtistId: SortOrder
}

input AlbumUpdateInput {
  AlbumId: IntFieldUpdateOperationsInput
  Artist: ArtistUpdateOneRequiredWithoutAlbumNestedInput
  Title: StringFieldUpdateOperationsInput
  Track: TrackUpdateManyWithoutAlbumNestedInput
}

input AlbumUpdateManyMutationInput {
  AlbumId: IntFieldUpdateOperationsInput
  Title: StringFieldUpdateOperationsInput
}

input AlbumUpdateManyWithWhereWithoutArtistInput {
  data: AlbumUpdateManyMutationInput!
  where: AlbumScalarWhereInput!
}

input AlbumUpdateManyWithoutArtistNestedInput {
  connect: [AlbumWhereUniqueInput!]
  connectOrCreate: [AlbumCreateOrConnectWithoutArtistInput!]
  create: [AlbumCreateWithoutArtistInput!]
  createMany: AlbumCreateManyArtistInputEnvelope
  delete: [AlbumWhereUniqueInput!]
  deleteMany: [AlbumScalarWhereInput!]
  disconnect: [AlbumWhereUniqueInput!]
  set: [AlbumWhereUniqueInput!]
  update: [AlbumUpdateWithWhereUniqueWithoutArtistInput!]
  updateMany: [AlbumUpdateManyWithWhereWithoutArtistInput!]
  upsert: [AlbumUpsertWithWhereUniqueWithoutArtistInput!]
}

input AlbumUpdateOneWithoutTrackNestedInput {
  connect: AlbumWhereUniqueInput
  connectOrCreate: AlbumCreateOrConnectWithoutTrackInput
  create: AlbumCreateWithoutTrackInput
  delete: Boolean
  disconnect: Boolean
  update: AlbumUpdateWithoutTrackInput
  upsert: AlbumUpsertWithoutTrackInput
}

input AlbumUpdateWithWhereUniqueWithoutArtistInput {
  data: AlbumUpdateWithoutArtistInput!
  where: AlbumWhereUniqueInput!
}

input AlbumUpdateWithoutArtistInput {
  AlbumId: IntFieldUpdateOperationsInput
  Title: StringFieldUpdateOperationsInput
  Track: TrackUpdateManyWithoutAlbumNestedInput
}

input AlbumUpdateWithoutTrackInput {
  AlbumId: IntFieldUpdateOperationsInput
  Artist: ArtistUpdateOneRequiredWithoutAlbumNestedInput
  Title: StringFieldUpdateOperationsInput
}

input AlbumUpsertWithWhereUniqueWithoutArtistInput {
  create: AlbumCreateWithoutArtistInput!
  update: AlbumUpdateWithoutArtistInput!
  where: AlbumWhereUniqueInput!
}

input AlbumUpsertWithoutTrackInput {
  create: AlbumCreateWithoutTrackInput!
  update: AlbumUpdateWithoutTrackInput!
}

input AlbumWhereInput {
  AND: [AlbumWhereInput!]
  AlbumId: IntFilter
  Artist: ArtistRelationFilter
  ArtistId: IntFilter
  NOT: [AlbumWhereInput!]
  OR: [AlbumWhereInput!]
  Title: StringFilter
  Track: TrackListRelationFilter
}

input AlbumWhereUniqueInput {
  AlbumId: Int
}

type Artist {
  Album(cursor: AlbumWhereUniqueInput, distinct: [AlbumScalarFieldEnum!], orderBy: [AlbumOrderByWithRelationInput!], skip: Int, take: Int, where: AlbumWhereInput): [Album!]!
  ArtistId: Int!
  Name: String
  _count: ArtistCount
}

type ArtistAvgAggregate {
  ArtistId: Float
}

input ArtistAvgOrderByAggregateInput {
  ArtistId: SortOrder
}

type ArtistCount {
  Album: Int!
}

type ArtistCountAggregate {
  ArtistId: Int!
  Name: Int!
  _all: Int!
}

input ArtistCountOrderByAggregateInput {
  ArtistId: SortOrder
  Name: SortOrder
}

input ArtistCreateInput {
  Album: AlbumCreateNestedManyWithoutArtistInput
  ArtistId: Int!
  Name: String
}

input ArtistCreateManyInput {
  ArtistId: Int!
  Name: String
}

input ArtistCreateNestedOneWithoutAlbumInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutAlbumInput
  create: ArtistCreateWithoutAlbumInput
}

input ArtistCreateOrConnectWithoutAlbumInput {
  create: ArtistCreateWithoutAlbumInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateWithoutAlbumInput {
  ArtistId: Int!
  Name: String
}

type ArtistGroupBy {
  ArtistId: Int!
  Name: String
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
}

type ArtistMaxAggregate {
  ArtistId: Int
  Name: String
}

input ArtistMaxOrderByAggregateInput {
  ArtistId: SortOrder
  Name: SortOrder
}

type ArtistMinAggregate {
  ArtistId: Int
  Name: String
}

input ArtistMinOrderByAggregateInput {
  ArtistId: SortOrder
  Name: SortOrder
}

input ArtistOrderByWithAggregationInput {
  ArtistId: SortOrder
  Name: SortOrder
  _avg: ArtistAvgOrderByAggregateInput
  _count: ArtistCountOrderByAggregateInput
  _max: ArtistMaxOrderByAggregateInput
  _min: ArtistMinOrderByAggregateInput
  _sum: ArtistSumOrderByAggregateInput
}

input ArtistOrderByWithRelationInput {
  Album: AlbumOrderByRelationAggregateInput
  ArtistId: SortOrder
  Name: SortOrder
}

input ArtistRelationFilter {
  is: ArtistWhereInput
  isNot: ArtistWhereInput
}

enum ArtistScalarFieldEnum {
  ArtistId
  Name
}

input ArtistScalarWhereWithAggregatesInput {
  AND: [ArtistScalarWhereWithAggregatesInput!]
  ArtistId: IntWithAggregatesFilter
  NOT: [ArtistScalarWhereWithAggregatesInput!]
  Name: StringNullableWithAggregatesFilter
  OR: [ArtistScalarWhereWithAggregatesInput!]
}

type ArtistSumAggregate {
  ArtistId: Int
}

input ArtistSumOrderByAggregateInput {
  ArtistId: SortOrder
}

input ArtistUpdateInput {
  Album: AlbumUpdateManyWithoutArtistNestedInput
  ArtistId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input ArtistUpdateManyMutationInput {
  ArtistId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input ArtistUpdateOneRequiredWithoutAlbumNestedInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutAlbumInput
  create: ArtistCreateWithoutAlbumInput
  update: ArtistUpdateWithoutAlbumInput
  upsert: ArtistUpsertWithoutAlbumInput
}

input ArtistUpdateWithoutAlbumInput {
  ArtistId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input ArtistUpsertWithoutAlbumInput {
  create: ArtistCreateWithoutAlbumInput!
  update: ArtistUpdateWithoutAlbumInput!
}

input ArtistWhereInput {
  AND: [ArtistWhereInput!]
  Album: AlbumListRelationFilter
  ArtistId: IntFilter
  NOT: [ArtistWhereInput!]
  Name: StringNullableFilter
  OR: [ArtistWhereInput!]
}

input ArtistWhereUniqueInput {
  ArtistId: Int
}

type Customer {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Employee: Employee
  Fax: String
  FirstName: String!
  Invoice(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceWhereInput): [Invoice!]!
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  SupportRepId: Int
  _count: CustomerCount
}

type CustomerAvgAggregate {
  CustomerId: Float
  SupportRepId: Float
}

input CustomerAvgOrderByAggregateInput {
  CustomerId: SortOrder
  SupportRepId: SortOrder
}

type CustomerCount {
  Invoice: Int!
}

type CustomerCountAggregate {
  Address: Int!
  City: Int!
  Company: Int!
  Country: Int!
  CustomerId: Int!
  Email: Int!
  Fax: Int!
  FirstName: Int!
  LastName: Int!
  Phone: Int!
  PostalCode: Int!
  State: Int!
  SupportRepId: Int!
  _all: Int!
}

input CustomerCountOrderByAggregateInput {
  Address: SortOrder
  City: SortOrder
  Company: SortOrder
  Country: SortOrder
  CustomerId: SortOrder
  Email: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  State: SortOrder
  SupportRepId: SortOrder
}

input CustomerCreateInput {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Employee: EmployeeCreateNestedOneWithoutCustomerInput
  Fax: String
  FirstName: String!
  Invoice: InvoiceCreateNestedManyWithoutCustomerInput
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
}

input CustomerCreateManyEmployeeInput {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Fax: String
  FirstName: String!
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
}

input CustomerCreateManyEmployeeInputEnvelope {
  data: [CustomerCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input CustomerCreateManyInput {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Fax: String
  FirstName: String!
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  SupportRepId: Int
}

input CustomerCreateNestedManyWithoutEmployeeInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutEmployeeInput!]
  create: [CustomerCreateWithoutEmployeeInput!]
  createMany: CustomerCreateManyEmployeeInputEnvelope
}

input CustomerCreateNestedOneWithoutInvoiceInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutInvoiceInput
  create: CustomerCreateWithoutInvoiceInput
}

input CustomerCreateOrConnectWithoutEmployeeInput {
  create: CustomerCreateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutInvoiceInput {
  create: CustomerCreateWithoutInvoiceInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutEmployeeInput {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Fax: String
  FirstName: String!
  Invoice: InvoiceCreateNestedManyWithoutCustomerInput
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
}

input CustomerCreateWithoutInvoiceInput {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Employee: EmployeeCreateNestedOneWithoutCustomerInput
  Fax: String
  FirstName: String!
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
}

type CustomerGroupBy {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int!
  Email: String!
  Fax: String
  FirstName: String!
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  SupportRepId: Int
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregate {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int
  Email: String
  Fax: String
  FirstName: String
  LastName: String
  Phone: String
  PostalCode: String
  State: String
  SupportRepId: Int
}

input CustomerMaxOrderByAggregateInput {
  Address: SortOrder
  City: SortOrder
  Company: SortOrder
  Country: SortOrder
  CustomerId: SortOrder
  Email: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  State: SortOrder
  SupportRepId: SortOrder
}

type CustomerMinAggregate {
  Address: String
  City: String
  Company: String
  Country: String
  CustomerId: Int
  Email: String
  Fax: String
  FirstName: String
  LastName: String
  Phone: String
  PostalCode: String
  State: String
  SupportRepId: Int
}

input CustomerMinOrderByAggregateInput {
  Address: SortOrder
  City: SortOrder
  Company: SortOrder
  Country: SortOrder
  CustomerId: SortOrder
  Email: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  State: SortOrder
  SupportRepId: SortOrder
}

input CustomerOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerOrderByWithAggregationInput {
  Address: SortOrder
  City: SortOrder
  Company: SortOrder
  Country: SortOrder
  CustomerId: SortOrder
  Email: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  State: SortOrder
  SupportRepId: SortOrder
  _avg: CustomerAvgOrderByAggregateInput
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  _sum: CustomerSumOrderByAggregateInput
}

input CustomerOrderByWithRelationInput {
  Address: SortOrder
  City: SortOrder
  Company: SortOrder
  Country: SortOrder
  CustomerId: SortOrder
  Email: SortOrder
  Employee: EmployeeOrderByWithRelationInput
  Fax: SortOrder
  FirstName: SortOrder
  Invoice: InvoiceOrderByRelationAggregateInput
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  State: SortOrder
  SupportRepId: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  Address
  City
  Company
  Country
  CustomerId
  Email
  Fax
  FirstName
  LastName
  Phone
  PostalCode
  State
  SupportRepId
}

input CustomerScalarWhereInput {
  AND: [CustomerScalarWhereInput!]
  Address: StringNullableFilter
  City: StringNullableFilter
  Company: StringNullableFilter
  Country: StringNullableFilter
  CustomerId: IntFilter
  Email: StringFilter
  Fax: StringNullableFilter
  FirstName: StringFilter
  LastName: StringFilter
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  Phone: StringNullableFilter
  PostalCode: StringNullableFilter
  State: StringNullableFilter
  SupportRepId: IntNullableFilter
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  Address: StringNullableWithAggregatesFilter
  City: StringNullableWithAggregatesFilter
  Company: StringNullableWithAggregatesFilter
  Country: StringNullableWithAggregatesFilter
  CustomerId: IntWithAggregatesFilter
  Email: StringWithAggregatesFilter
  Fax: StringNullableWithAggregatesFilter
  FirstName: StringWithAggregatesFilter
  LastName: StringWithAggregatesFilter
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  Phone: StringNullableWithAggregatesFilter
  PostalCode: StringNullableWithAggregatesFilter
  State: StringNullableWithAggregatesFilter
  SupportRepId: IntNullableWithAggregatesFilter
}

type CustomerSumAggregate {
  CustomerId: Int
  SupportRepId: Int
}

input CustomerSumOrderByAggregateInput {
  CustomerId: SortOrder
  SupportRepId: SortOrder
}

input CustomerUpdateInput {
  Address: NullableStringFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Company: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  CustomerId: IntFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutCustomerNestedInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  Invoice: InvoiceUpdateManyWithoutCustomerNestedInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyMutationInput {
  Address: NullableStringFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Company: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  CustomerId: IntFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyWithWhereWithoutEmployeeInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithoutEmployeeNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutEmployeeInput!]
  create: [CustomerCreateWithoutEmployeeInput!]
  createMany: CustomerCreateManyEmployeeInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutEmployeeInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input CustomerUpdateOneRequiredWithoutInvoiceNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutInvoiceInput
  create: CustomerCreateWithoutInvoiceInput
  update: CustomerUpdateWithoutInvoiceInput
  upsert: CustomerUpsertWithoutInvoiceInput
}

input CustomerUpdateWithWhereUniqueWithoutEmployeeInput {
  data: CustomerUpdateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithoutEmployeeInput {
  Address: NullableStringFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Company: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  CustomerId: IntFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  Invoice: InvoiceUpdateManyWithoutCustomerNestedInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithoutInvoiceInput {
  Address: NullableStringFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Company: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  CustomerId: IntFieldUpdateOperationsInput
  Email: StringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutCustomerNestedInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
}

input CustomerUpsertWithWhereUniqueWithoutEmployeeInput {
  create: CustomerCreateWithoutEmployeeInput!
  update: CustomerUpdateWithoutEmployeeInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutInvoiceInput {
  create: CustomerCreateWithoutInvoiceInput!
  update: CustomerUpdateWithoutInvoiceInput!
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  Address: StringNullableFilter
  City: StringNullableFilter
  Company: StringNullableFilter
  Country: StringNullableFilter
  CustomerId: IntFilter
  Email: StringFilter
  Employee: EmployeeRelationFilter
  Fax: StringNullableFilter
  FirstName: StringFilter
  Invoice: InvoiceListRelationFilter
  LastName: StringFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  Phone: StringNullableFilter
  PostalCode: StringNullableFilter
  State: StringNullableFilter
  SupportRepId: IntNullableFilter
}

input CustomerWhereUniqueInput {
  CustomerId: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

type Employee {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Customer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  Email: String
  Employee: Employee
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  ReportsTo: Int
  State: String
  Title: String
  _count: EmployeeCount
  other_Employee(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
}

type EmployeeAvgAggregate {
  EmployeeId: Float
  ReportsTo: Float
}

input EmployeeAvgOrderByAggregateInput {
  EmployeeId: SortOrder
  ReportsTo: SortOrder
}

type EmployeeCount {
  Customer: Int!
  other_Employee: Int!
}

type EmployeeCountAggregate {
  Address: Int!
  BirthDate: Int!
  City: Int!
  Country: Int!
  Email: Int!
  EmployeeId: Int!
  Fax: Int!
  FirstName: Int!
  HireDate: Int!
  LastName: Int!
  Phone: Int!
  PostalCode: Int!
  ReportsTo: Int!
  State: Int!
  Title: Int!
  _all: Int!
}

input EmployeeCountOrderByAggregateInput {
  Address: SortOrder
  BirthDate: SortOrder
  City: SortOrder
  Country: SortOrder
  Email: SortOrder
  EmployeeId: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  HireDate: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  ReportsTo: SortOrder
  State: SortOrder
  Title: SortOrder
}

input EmployeeCreateInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Customer: CustomerCreateNestedManyWithoutEmployeeInput
  Email: String
  Employee: EmployeeCreateNestedOneWithoutOther_EmployeeInput
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  Title: String
  other_Employee: EmployeeCreateNestedManyWithoutEmployeeInput
}

input EmployeeCreateManyEmployeeInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  Title: String
}

input EmployeeCreateManyEmployeeInputEnvelope {
  data: [EmployeeCreateManyEmployeeInput!]!
  skipDuplicates: Boolean
}

input EmployeeCreateManyInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  ReportsTo: Int
  State: String
  Title: String
}

input EmployeeCreateNestedManyWithoutEmployeeInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutEmployeeInput!]
  create: [EmployeeCreateWithoutEmployeeInput!]
  createMany: EmployeeCreateManyEmployeeInputEnvelope
}

input EmployeeCreateNestedOneWithoutCustomerInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutCustomerInput
  create: EmployeeCreateWithoutCustomerInput
}

input EmployeeCreateNestedOneWithoutOther_EmployeeInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutOther_EmployeeInput
  create: EmployeeCreateWithoutOther_EmployeeInput
}

input EmployeeCreateOrConnectWithoutCustomerInput {
  create: EmployeeCreateWithoutCustomerInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutEmployeeInput {
  create: EmployeeCreateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutOther_EmployeeInput {
  create: EmployeeCreateWithoutOther_EmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateWithoutCustomerInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  Employee: EmployeeCreateNestedOneWithoutOther_EmployeeInput
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  Title: String
  other_Employee: EmployeeCreateNestedManyWithoutEmployeeInput
}

input EmployeeCreateWithoutEmployeeInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Customer: CustomerCreateNestedManyWithoutEmployeeInput
  Email: String
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  Title: String
  other_Employee: EmployeeCreateNestedManyWithoutEmployeeInput
}

input EmployeeCreateWithoutOther_EmployeeInput {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Customer: CustomerCreateNestedManyWithoutEmployeeInput
  Email: String
  Employee: EmployeeCreateNestedOneWithoutOther_EmployeeInput
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  State: String
  Title: String
}

type EmployeeGroupBy {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  EmployeeId: Int!
  Fax: String
  FirstName: String!
  HireDate: DateTime
  LastName: String!
  Phone: String
  PostalCode: String
  ReportsTo: Int
  State: String
  Title: String
  _avg: EmployeeAvgAggregate
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
  _sum: EmployeeSumAggregate
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeeMaxAggregate {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  EmployeeId: Int
  Fax: String
  FirstName: String
  HireDate: DateTime
  LastName: String
  Phone: String
  PostalCode: String
  ReportsTo: Int
  State: String
  Title: String
}

input EmployeeMaxOrderByAggregateInput {
  Address: SortOrder
  BirthDate: SortOrder
  City: SortOrder
  Country: SortOrder
  Email: SortOrder
  EmployeeId: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  HireDate: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  ReportsTo: SortOrder
  State: SortOrder
  Title: SortOrder
}

type EmployeeMinAggregate {
  Address: String
  BirthDate: DateTime
  City: String
  Country: String
  Email: String
  EmployeeId: Int
  Fax: String
  FirstName: String
  HireDate: DateTime
  LastName: String
  Phone: String
  PostalCode: String
  ReportsTo: Int
  State: String
  Title: String
}

input EmployeeMinOrderByAggregateInput {
  Address: SortOrder
  BirthDate: SortOrder
  City: SortOrder
  Country: SortOrder
  Email: SortOrder
  EmployeeId: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  HireDate: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  ReportsTo: SortOrder
  State: SortOrder
  Title: SortOrder
}

input EmployeeOrderByRelationAggregateInput {
  _count: SortOrder
}

input EmployeeOrderByWithAggregationInput {
  Address: SortOrder
  BirthDate: SortOrder
  City: SortOrder
  Country: SortOrder
  Email: SortOrder
  EmployeeId: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  HireDate: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  ReportsTo: SortOrder
  State: SortOrder
  Title: SortOrder
  _avg: EmployeeAvgOrderByAggregateInput
  _count: EmployeeCountOrderByAggregateInput
  _max: EmployeeMaxOrderByAggregateInput
  _min: EmployeeMinOrderByAggregateInput
  _sum: EmployeeSumOrderByAggregateInput
}

input EmployeeOrderByWithRelationInput {
  Address: SortOrder
  BirthDate: SortOrder
  City: SortOrder
  Country: SortOrder
  Customer: CustomerOrderByRelationAggregateInput
  Email: SortOrder
  Employee: EmployeeOrderByWithRelationInput
  EmployeeId: SortOrder
  Fax: SortOrder
  FirstName: SortOrder
  HireDate: SortOrder
  LastName: SortOrder
  Phone: SortOrder
  PostalCode: SortOrder
  ReportsTo: SortOrder
  State: SortOrder
  Title: SortOrder
  other_Employee: EmployeeOrderByRelationAggregateInput
}

input EmployeeRelationFilter {
  is: EmployeeWhereInput
  isNot: EmployeeWhereInput
}

enum EmployeeScalarFieldEnum {
  Address
  BirthDate
  City
  Country
  Email
  EmployeeId
  Fax
  FirstName
  HireDate
  LastName
  Phone
  PostalCode
  ReportsTo
  State
  Title
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput!]
  Address: StringNullableFilter
  BirthDate: DateTimeNullableFilter
  City: StringNullableFilter
  Country: StringNullableFilter
  Email: StringNullableFilter
  EmployeeId: IntFilter
  Fax: StringNullableFilter
  FirstName: StringFilter
  HireDate: DateTimeNullableFilter
  LastName: StringFilter
  NOT: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
  Phone: StringNullableFilter
  PostalCode: StringNullableFilter
  ReportsTo: IntNullableFilter
  State: StringNullableFilter
  Title: StringNullableFilter
}

input EmployeeScalarWhereWithAggregatesInput {
  AND: [EmployeeScalarWhereWithAggregatesInput!]
  Address: StringNullableWithAggregatesFilter
  BirthDate: DateTimeNullableWithAggregatesFilter
  City: StringNullableWithAggregatesFilter
  Country: StringNullableWithAggregatesFilter
  Email: StringNullableWithAggregatesFilter
  EmployeeId: IntWithAggregatesFilter
  Fax: StringNullableWithAggregatesFilter
  FirstName: StringWithAggregatesFilter
  HireDate: DateTimeNullableWithAggregatesFilter
  LastName: StringWithAggregatesFilter
  NOT: [EmployeeScalarWhereWithAggregatesInput!]
  OR: [EmployeeScalarWhereWithAggregatesInput!]
  Phone: StringNullableWithAggregatesFilter
  PostalCode: StringNullableWithAggregatesFilter
  ReportsTo: IntNullableWithAggregatesFilter
  State: StringNullableWithAggregatesFilter
  Title: StringNullableWithAggregatesFilter
}

type EmployeeSumAggregate {
  EmployeeId: Int
  ReportsTo: Int
}

input EmployeeSumOrderByAggregateInput {
  EmployeeId: SortOrder
  ReportsTo: SortOrder
}

input EmployeeUpdateInput {
  Address: NullableStringFieldUpdateOperationsInput
  BirthDate: NullableDateTimeFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateManyWithoutEmployeeNestedInput
  Email: NullableStringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
  EmployeeId: IntFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  HireDate: NullableDateTimeFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
  other_Employee: EmployeeUpdateManyWithoutEmployeeNestedInput
}

input EmployeeUpdateManyMutationInput {
  Address: NullableStringFieldUpdateOperationsInput
  BirthDate: NullableDateTimeFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  Email: NullableStringFieldUpdateOperationsInput
  EmployeeId: IntFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  HireDate: NullableDateTimeFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input EmployeeUpdateManyWithWhereWithoutEmployeeInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithoutEmployeeNestedInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutEmployeeInput!]
  create: [EmployeeCreateWithoutEmployeeInput!]
  createMany: EmployeeCreateManyEmployeeInputEnvelope
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutEmployeeInput!]
  updateMany: [EmployeeUpdateManyWithWhereWithoutEmployeeInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutEmployeeInput!]
}

input EmployeeUpdateOneWithoutCustomerNestedInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutCustomerInput
  create: EmployeeCreateWithoutCustomerInput
  delete: Boolean
  disconnect: Boolean
  update: EmployeeUpdateWithoutCustomerInput
  upsert: EmployeeUpsertWithoutCustomerInput
}

input EmployeeUpdateOneWithoutOther_EmployeeNestedInput {
  connect: EmployeeWhereUniqueInput
  connectOrCreate: EmployeeCreateOrConnectWithoutOther_EmployeeInput
  create: EmployeeCreateWithoutOther_EmployeeInput
  delete: Boolean
  disconnect: Boolean
  update: EmployeeUpdateWithoutOther_EmployeeInput
  upsert: EmployeeUpsertWithoutOther_EmployeeInput
}

input EmployeeUpdateWithWhereUniqueWithoutEmployeeInput {
  data: EmployeeUpdateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithoutCustomerInput {
  Address: NullableStringFieldUpdateOperationsInput
  BirthDate: NullableDateTimeFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  Email: NullableStringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
  EmployeeId: IntFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  HireDate: NullableDateTimeFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
  other_Employee: EmployeeUpdateManyWithoutEmployeeNestedInput
}

input EmployeeUpdateWithoutEmployeeInput {
  Address: NullableStringFieldUpdateOperationsInput
  BirthDate: NullableDateTimeFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateManyWithoutEmployeeNestedInput
  Email: NullableStringFieldUpdateOperationsInput
  EmployeeId: IntFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  HireDate: NullableDateTimeFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
  other_Employee: EmployeeUpdateManyWithoutEmployeeNestedInput
}

input EmployeeUpdateWithoutOther_EmployeeInput {
  Address: NullableStringFieldUpdateOperationsInput
  BirthDate: NullableDateTimeFieldUpdateOperationsInput
  City: NullableStringFieldUpdateOperationsInput
  Country: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateManyWithoutEmployeeNestedInput
  Email: NullableStringFieldUpdateOperationsInput
  Employee: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
  EmployeeId: IntFieldUpdateOperationsInput
  Fax: NullableStringFieldUpdateOperationsInput
  FirstName: StringFieldUpdateOperationsInput
  HireDate: NullableDateTimeFieldUpdateOperationsInput
  LastName: StringFieldUpdateOperationsInput
  Phone: NullableStringFieldUpdateOperationsInput
  PostalCode: NullableStringFieldUpdateOperationsInput
  State: NullableStringFieldUpdateOperationsInput
  Title: NullableStringFieldUpdateOperationsInput
}

input EmployeeUpsertWithWhereUniqueWithoutEmployeeInput {
  create: EmployeeCreateWithoutEmployeeInput!
  update: EmployeeUpdateWithoutEmployeeInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithoutCustomerInput {
  create: EmployeeCreateWithoutCustomerInput!
  update: EmployeeUpdateWithoutCustomerInput!
}

input EmployeeUpsertWithoutOther_EmployeeInput {
  create: EmployeeCreateWithoutOther_EmployeeInput!
  update: EmployeeUpdateWithoutOther_EmployeeInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  Address: StringNullableFilter
  BirthDate: DateTimeNullableFilter
  City: StringNullableFilter
  Country: StringNullableFilter
  Customer: CustomerListRelationFilter
  Email: StringNullableFilter
  Employee: EmployeeRelationFilter
  EmployeeId: IntFilter
  Fax: StringNullableFilter
  FirstName: StringFilter
  HireDate: DateTimeNullableFilter
  LastName: StringFilter
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  Phone: StringNullableFilter
  PostalCode: StringNullableFilter
  ReportsTo: IntNullableFilter
  State: StringNullableFilter
  Title: StringNullableFilter
  other_Employee: EmployeeListRelationFilter
}

input EmployeeWhereUniqueInput {
  EmployeeId: Int
}

type Genre {
  GenreId: Int!
  Name: String
  Track(cursor: TrackWhereUniqueInput, distinct: [TrackScalarFieldEnum!], orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): [Track!]!
  _count: GenreCount
}

type GenreAvgAggregate {
  GenreId: Float
}

input GenreAvgOrderByAggregateInput {
  GenreId: SortOrder
}

type GenreCount {
  Track: Int!
}

type GenreCountAggregate {
  GenreId: Int!
  Name: Int!
  _all: Int!
}

input GenreCountOrderByAggregateInput {
  GenreId: SortOrder
  Name: SortOrder
}

input GenreCreateInput {
  GenreId: Int!
  Name: String
  Track: TrackCreateNestedManyWithoutGenreInput
}

input GenreCreateManyInput {
  GenreId: Int!
  Name: String
}

input GenreCreateNestedOneWithoutTrackInput {
  connect: GenreWhereUniqueInput
  connectOrCreate: GenreCreateOrConnectWithoutTrackInput
  create: GenreCreateWithoutTrackInput
}

input GenreCreateOrConnectWithoutTrackInput {
  create: GenreCreateWithoutTrackInput!
  where: GenreWhereUniqueInput!
}

input GenreCreateWithoutTrackInput {
  GenreId: Int!
  Name: String
}

type GenreGroupBy {
  GenreId: Int!
  Name: String
  _avg: GenreAvgAggregate
  _count: GenreCountAggregate
  _max: GenreMaxAggregate
  _min: GenreMinAggregate
  _sum: GenreSumAggregate
}

type GenreMaxAggregate {
  GenreId: Int
  Name: String
}

input GenreMaxOrderByAggregateInput {
  GenreId: SortOrder
  Name: SortOrder
}

type GenreMinAggregate {
  GenreId: Int
  Name: String
}

input GenreMinOrderByAggregateInput {
  GenreId: SortOrder
  Name: SortOrder
}

input GenreOrderByWithAggregationInput {
  GenreId: SortOrder
  Name: SortOrder
  _avg: GenreAvgOrderByAggregateInput
  _count: GenreCountOrderByAggregateInput
  _max: GenreMaxOrderByAggregateInput
  _min: GenreMinOrderByAggregateInput
  _sum: GenreSumOrderByAggregateInput
}

input GenreOrderByWithRelationInput {
  GenreId: SortOrder
  Name: SortOrder
  Track: TrackOrderByRelationAggregateInput
}

input GenreRelationFilter {
  is: GenreWhereInput
  isNot: GenreWhereInput
}

enum GenreScalarFieldEnum {
  GenreId
  Name
}

input GenreScalarWhereWithAggregatesInput {
  AND: [GenreScalarWhereWithAggregatesInput!]
  GenreId: IntWithAggregatesFilter
  NOT: [GenreScalarWhereWithAggregatesInput!]
  Name: StringNullableWithAggregatesFilter
  OR: [GenreScalarWhereWithAggregatesInput!]
}

type GenreSumAggregate {
  GenreId: Int
}

input GenreSumOrderByAggregateInput {
  GenreId: SortOrder
}

input GenreUpdateInput {
  GenreId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
  Track: TrackUpdateManyWithoutGenreNestedInput
}

input GenreUpdateManyMutationInput {
  GenreId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input GenreUpdateOneWithoutTrackNestedInput {
  connect: GenreWhereUniqueInput
  connectOrCreate: GenreCreateOrConnectWithoutTrackInput
  create: GenreCreateWithoutTrackInput
  delete: Boolean
  disconnect: Boolean
  update: GenreUpdateWithoutTrackInput
  upsert: GenreUpsertWithoutTrackInput
}

input GenreUpdateWithoutTrackInput {
  GenreId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input GenreUpsertWithoutTrackInput {
  create: GenreCreateWithoutTrackInput!
  update: GenreUpdateWithoutTrackInput!
}

input GenreWhereInput {
  AND: [GenreWhereInput!]
  GenreId: IntFilter
  NOT: [GenreWhereInput!]
  Name: StringNullableFilter
  OR: [GenreWhereInput!]
  Track: TrackListRelationFilter
}

input GenreWhereUniqueInput {
  GenreId: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Invoice {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  Customer: Customer!
  CustomerId: Int!
  InvoiceDate: DateTime!
  InvoiceId: Int!
  InvoiceLine(cursor: InvoiceLineWhereUniqueInput, distinct: [InvoiceLineScalarFieldEnum!], orderBy: [InvoiceLineOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): [InvoiceLine!]!
  Total: Decimal!
  _count: InvoiceCount
}

type InvoiceAvgAggregate {
  CustomerId: Float
  InvoiceId: Float
  Total: Decimal
}

input InvoiceAvgOrderByAggregateInput {
  CustomerId: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
}

type InvoiceCount {
  InvoiceLine: Int!
}

type InvoiceCountAggregate {
  BillingAddress: Int!
  BillingCity: Int!
  BillingCountry: Int!
  BillingPostalCode: Int!
  BillingState: Int!
  CustomerId: Int!
  InvoiceDate: Int!
  InvoiceId: Int!
  Total: Int!
  _all: Int!
}

input InvoiceCountOrderByAggregateInput {
  BillingAddress: SortOrder
  BillingCity: SortOrder
  BillingCountry: SortOrder
  BillingPostalCode: SortOrder
  BillingState: SortOrder
  CustomerId: SortOrder
  InvoiceDate: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
}

input InvoiceCreateInput {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  Customer: CustomerCreateNestedOneWithoutInvoiceInput!
  InvoiceDate: DateTime!
  InvoiceId: Int!
  InvoiceLine: InvoiceLineCreateNestedManyWithoutInvoiceInput
  Total: Decimal!
}

input InvoiceCreateManyCustomerInput {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  InvoiceDate: DateTime!
  InvoiceId: Int!
  Total: Decimal!
}

input InvoiceCreateManyCustomerInputEnvelope {
  data: [InvoiceCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input InvoiceCreateManyInput {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  CustomerId: Int!
  InvoiceDate: DateTime!
  InvoiceId: Int!
  Total: Decimal!
}

input InvoiceCreateNestedManyWithoutCustomerInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutCustomerInput!]
  create: [InvoiceCreateWithoutCustomerInput!]
  createMany: InvoiceCreateManyCustomerInputEnvelope
}

input InvoiceCreateNestedOneWithoutInvoiceLineInput {
  connect: InvoiceWhereUniqueInput
  connectOrCreate: InvoiceCreateOrConnectWithoutInvoiceLineInput
  create: InvoiceCreateWithoutInvoiceLineInput
}

input InvoiceCreateOrConnectWithoutCustomerInput {
  create: InvoiceCreateWithoutCustomerInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceCreateOrConnectWithoutInvoiceLineInput {
  create: InvoiceCreateWithoutInvoiceLineInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceCreateWithoutCustomerInput {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  InvoiceDate: DateTime!
  InvoiceId: Int!
  InvoiceLine: InvoiceLineCreateNestedManyWithoutInvoiceInput
  Total: Decimal!
}

input InvoiceCreateWithoutInvoiceLineInput {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  Customer: CustomerCreateNestedOneWithoutInvoiceInput!
  InvoiceDate: DateTime!
  InvoiceId: Int!
  Total: Decimal!
}

type InvoiceGroupBy {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  CustomerId: Int!
  InvoiceDate: DateTime!
  InvoiceId: Int!
  Total: Decimal!
  _avg: InvoiceAvgAggregate
  _count: InvoiceCountAggregate
  _max: InvoiceMaxAggregate
  _min: InvoiceMinAggregate
  _sum: InvoiceSumAggregate
}

type InvoiceLine {
  Invoice: Invoice!
  InvoiceId: Int!
  InvoiceLineId: Int!
  Quantity: Int!
  Track: Track!
  TrackId: Int!
  UnitPrice: Decimal!
}

type InvoiceLineAvgAggregate {
  InvoiceId: Float
  InvoiceLineId: Float
  Quantity: Float
  TrackId: Float
  UnitPrice: Decimal
}

input InvoiceLineAvgOrderByAggregateInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

type InvoiceLineCountAggregate {
  InvoiceId: Int!
  InvoiceLineId: Int!
  Quantity: Int!
  TrackId: Int!
  UnitPrice: Int!
  _all: Int!
}

input InvoiceLineCountOrderByAggregateInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input InvoiceLineCreateInput {
  Invoice: InvoiceCreateNestedOneWithoutInvoiceLineInput!
  InvoiceLineId: Int!
  Quantity: Int!
  Track: TrackCreateNestedOneWithoutInvoiceLineInput!
  UnitPrice: Decimal!
}

input InvoiceLineCreateManyInput {
  InvoiceId: Int!
  InvoiceLineId: Int!
  Quantity: Int!
  TrackId: Int!
  UnitPrice: Decimal!
}

input InvoiceLineCreateManyInvoiceInput {
  InvoiceLineId: Int!
  Quantity: Int!
  TrackId: Int!
  UnitPrice: Decimal!
}

input InvoiceLineCreateManyInvoiceInputEnvelope {
  data: [InvoiceLineCreateManyInvoiceInput!]!
  skipDuplicates: Boolean
}

input InvoiceLineCreateManyTrackInput {
  InvoiceId: Int!
  InvoiceLineId: Int!
  Quantity: Int!
  UnitPrice: Decimal!
}

input InvoiceLineCreateManyTrackInputEnvelope {
  data: [InvoiceLineCreateManyTrackInput!]!
  skipDuplicates: Boolean
}

input InvoiceLineCreateNestedManyWithoutInvoiceInput {
  connect: [InvoiceLineWhereUniqueInput!]
  connectOrCreate: [InvoiceLineCreateOrConnectWithoutInvoiceInput!]
  create: [InvoiceLineCreateWithoutInvoiceInput!]
  createMany: InvoiceLineCreateManyInvoiceInputEnvelope
}

input InvoiceLineCreateNestedManyWithoutTrackInput {
  connect: [InvoiceLineWhereUniqueInput!]
  connectOrCreate: [InvoiceLineCreateOrConnectWithoutTrackInput!]
  create: [InvoiceLineCreateWithoutTrackInput!]
  createMany: InvoiceLineCreateManyTrackInputEnvelope
}

input InvoiceLineCreateOrConnectWithoutInvoiceInput {
  create: InvoiceLineCreateWithoutInvoiceInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineCreateOrConnectWithoutTrackInput {
  create: InvoiceLineCreateWithoutTrackInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineCreateWithoutInvoiceInput {
  InvoiceLineId: Int!
  Quantity: Int!
  Track: TrackCreateNestedOneWithoutInvoiceLineInput!
  UnitPrice: Decimal!
}

input InvoiceLineCreateWithoutTrackInput {
  Invoice: InvoiceCreateNestedOneWithoutInvoiceLineInput!
  InvoiceLineId: Int!
  Quantity: Int!
  UnitPrice: Decimal!
}

type InvoiceLineGroupBy {
  InvoiceId: Int!
  InvoiceLineId: Int!
  Quantity: Int!
  TrackId: Int!
  UnitPrice: Decimal!
  _avg: InvoiceLineAvgAggregate
  _count: InvoiceLineCountAggregate
  _max: InvoiceLineMaxAggregate
  _min: InvoiceLineMinAggregate
  _sum: InvoiceLineSumAggregate
}

input InvoiceLineListRelationFilter {
  every: InvoiceLineWhereInput
  none: InvoiceLineWhereInput
  some: InvoiceLineWhereInput
}

type InvoiceLineMaxAggregate {
  InvoiceId: Int
  InvoiceLineId: Int
  Quantity: Int
  TrackId: Int
  UnitPrice: Decimal
}

input InvoiceLineMaxOrderByAggregateInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

type InvoiceLineMinAggregate {
  InvoiceId: Int
  InvoiceLineId: Int
  Quantity: Int
  TrackId: Int
  UnitPrice: Decimal
}

input InvoiceLineMinOrderByAggregateInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input InvoiceLineOrderByRelationAggregateInput {
  _count: SortOrder
}

input InvoiceLineOrderByWithAggregationInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
  _avg: InvoiceLineAvgOrderByAggregateInput
  _count: InvoiceLineCountOrderByAggregateInput
  _max: InvoiceLineMaxOrderByAggregateInput
  _min: InvoiceLineMinOrderByAggregateInput
  _sum: InvoiceLineSumOrderByAggregateInput
}

input InvoiceLineOrderByWithRelationInput {
  Invoice: InvoiceOrderByWithRelationInput
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  Track: TrackOrderByWithRelationInput
  TrackId: SortOrder
  UnitPrice: SortOrder
}

enum InvoiceLineScalarFieldEnum {
  InvoiceId
  InvoiceLineId
  Quantity
  TrackId
  UnitPrice
}

input InvoiceLineScalarWhereInput {
  AND: [InvoiceLineScalarWhereInput!]
  InvoiceId: IntFilter
  InvoiceLineId: IntFilter
  NOT: [InvoiceLineScalarWhereInput!]
  OR: [InvoiceLineScalarWhereInput!]
  Quantity: IntFilter
  TrackId: IntFilter
  UnitPrice: DecimalFilter
}

input InvoiceLineScalarWhereWithAggregatesInput {
  AND: [InvoiceLineScalarWhereWithAggregatesInput!]
  InvoiceId: IntWithAggregatesFilter
  InvoiceLineId: IntWithAggregatesFilter
  NOT: [InvoiceLineScalarWhereWithAggregatesInput!]
  OR: [InvoiceLineScalarWhereWithAggregatesInput!]
  Quantity: IntWithAggregatesFilter
  TrackId: IntWithAggregatesFilter
  UnitPrice: DecimalWithAggregatesFilter
}

type InvoiceLineSumAggregate {
  InvoiceId: Int
  InvoiceLineId: Int
  Quantity: Int
  TrackId: Int
  UnitPrice: Decimal
}

input InvoiceLineSumOrderByAggregateInput {
  InvoiceId: SortOrder
  InvoiceLineId: SortOrder
  Quantity: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input InvoiceLineUpdateInput {
  Invoice: InvoiceUpdateOneRequiredWithoutInvoiceLineNestedInput
  InvoiceLineId: IntFieldUpdateOperationsInput
  Quantity: IntFieldUpdateOperationsInput
  Track: TrackUpdateOneRequiredWithoutInvoiceLineNestedInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input InvoiceLineUpdateManyMutationInput {
  InvoiceLineId: IntFieldUpdateOperationsInput
  Quantity: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input InvoiceLineUpdateManyWithWhereWithoutInvoiceInput {
  data: InvoiceLineUpdateManyMutationInput!
  where: InvoiceLineScalarWhereInput!
}

input InvoiceLineUpdateManyWithWhereWithoutTrackInput {
  data: InvoiceLineUpdateManyMutationInput!
  where: InvoiceLineScalarWhereInput!
}

input InvoiceLineUpdateManyWithoutInvoiceNestedInput {
  connect: [InvoiceLineWhereUniqueInput!]
  connectOrCreate: [InvoiceLineCreateOrConnectWithoutInvoiceInput!]
  create: [InvoiceLineCreateWithoutInvoiceInput!]
  createMany: InvoiceLineCreateManyInvoiceInputEnvelope
  delete: [InvoiceLineWhereUniqueInput!]
  deleteMany: [InvoiceLineScalarWhereInput!]
  disconnect: [InvoiceLineWhereUniqueInput!]
  set: [InvoiceLineWhereUniqueInput!]
  update: [InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput!]
  updateMany: [InvoiceLineUpdateManyWithWhereWithoutInvoiceInput!]
  upsert: [InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput!]
}

input InvoiceLineUpdateManyWithoutTrackNestedInput {
  connect: [InvoiceLineWhereUniqueInput!]
  connectOrCreate: [InvoiceLineCreateOrConnectWithoutTrackInput!]
  create: [InvoiceLineCreateWithoutTrackInput!]
  createMany: InvoiceLineCreateManyTrackInputEnvelope
  delete: [InvoiceLineWhereUniqueInput!]
  deleteMany: [InvoiceLineScalarWhereInput!]
  disconnect: [InvoiceLineWhereUniqueInput!]
  set: [InvoiceLineWhereUniqueInput!]
  update: [InvoiceLineUpdateWithWhereUniqueWithoutTrackInput!]
  updateMany: [InvoiceLineUpdateManyWithWhereWithoutTrackInput!]
  upsert: [InvoiceLineUpsertWithWhereUniqueWithoutTrackInput!]
}

input InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput {
  data: InvoiceLineUpdateWithoutInvoiceInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineUpdateWithWhereUniqueWithoutTrackInput {
  data: InvoiceLineUpdateWithoutTrackInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineUpdateWithoutInvoiceInput {
  InvoiceLineId: IntFieldUpdateOperationsInput
  Quantity: IntFieldUpdateOperationsInput
  Track: TrackUpdateOneRequiredWithoutInvoiceLineNestedInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input InvoiceLineUpdateWithoutTrackInput {
  Invoice: InvoiceUpdateOneRequiredWithoutInvoiceLineNestedInput
  InvoiceLineId: IntFieldUpdateOperationsInput
  Quantity: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput {
  create: InvoiceLineCreateWithoutInvoiceInput!
  update: InvoiceLineUpdateWithoutInvoiceInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineUpsertWithWhereUniqueWithoutTrackInput {
  create: InvoiceLineCreateWithoutTrackInput!
  update: InvoiceLineUpdateWithoutTrackInput!
  where: InvoiceLineWhereUniqueInput!
}

input InvoiceLineWhereInput {
  AND: [InvoiceLineWhereInput!]
  Invoice: InvoiceRelationFilter
  InvoiceId: IntFilter
  InvoiceLineId: IntFilter
  NOT: [InvoiceLineWhereInput!]
  OR: [InvoiceLineWhereInput!]
  Quantity: IntFilter
  Track: TrackRelationFilter
  TrackId: IntFilter
  UnitPrice: DecimalFilter
}

input InvoiceLineWhereUniqueInput {
  InvoiceLineId: Int
}

input InvoiceListRelationFilter {
  every: InvoiceWhereInput
  none: InvoiceWhereInput
  some: InvoiceWhereInput
}

type InvoiceMaxAggregate {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  CustomerId: Int
  InvoiceDate: DateTime
  InvoiceId: Int
  Total: Decimal
}

input InvoiceMaxOrderByAggregateInput {
  BillingAddress: SortOrder
  BillingCity: SortOrder
  BillingCountry: SortOrder
  BillingPostalCode: SortOrder
  BillingState: SortOrder
  CustomerId: SortOrder
  InvoiceDate: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
}

type InvoiceMinAggregate {
  BillingAddress: String
  BillingCity: String
  BillingCountry: String
  BillingPostalCode: String
  BillingState: String
  CustomerId: Int
  InvoiceDate: DateTime
  InvoiceId: Int
  Total: Decimal
}

input InvoiceMinOrderByAggregateInput {
  BillingAddress: SortOrder
  BillingCity: SortOrder
  BillingCountry: SortOrder
  BillingPostalCode: SortOrder
  BillingState: SortOrder
  CustomerId: SortOrder
  InvoiceDate: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
}

input InvoiceOrderByRelationAggregateInput {
  _count: SortOrder
}

input InvoiceOrderByWithAggregationInput {
  BillingAddress: SortOrder
  BillingCity: SortOrder
  BillingCountry: SortOrder
  BillingPostalCode: SortOrder
  BillingState: SortOrder
  CustomerId: SortOrder
  InvoiceDate: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
  _avg: InvoiceAvgOrderByAggregateInput
  _count: InvoiceCountOrderByAggregateInput
  _max: InvoiceMaxOrderByAggregateInput
  _min: InvoiceMinOrderByAggregateInput
  _sum: InvoiceSumOrderByAggregateInput
}

input InvoiceOrderByWithRelationInput {
  BillingAddress: SortOrder
  BillingCity: SortOrder
  BillingCountry: SortOrder
  BillingPostalCode: SortOrder
  BillingState: SortOrder
  Customer: CustomerOrderByWithRelationInput
  CustomerId: SortOrder
  InvoiceDate: SortOrder
  InvoiceId: SortOrder
  InvoiceLine: InvoiceLineOrderByRelationAggregateInput
  Total: SortOrder
}

input InvoiceRelationFilter {
  is: InvoiceWhereInput
  isNot: InvoiceWhereInput
}

enum InvoiceScalarFieldEnum {
  BillingAddress
  BillingCity
  BillingCountry
  BillingPostalCode
  BillingState
  CustomerId
  InvoiceDate
  InvoiceId
  Total
}

input InvoiceScalarWhereInput {
  AND: [InvoiceScalarWhereInput!]
  BillingAddress: StringNullableFilter
  BillingCity: StringNullableFilter
  BillingCountry: StringNullableFilter
  BillingPostalCode: StringNullableFilter
  BillingState: StringNullableFilter
  CustomerId: IntFilter
  InvoiceDate: DateTimeFilter
  InvoiceId: IntFilter
  NOT: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  Total: DecimalFilter
}

input InvoiceScalarWhereWithAggregatesInput {
  AND: [InvoiceScalarWhereWithAggregatesInput!]
  BillingAddress: StringNullableWithAggregatesFilter
  BillingCity: StringNullableWithAggregatesFilter
  BillingCountry: StringNullableWithAggregatesFilter
  BillingPostalCode: StringNullableWithAggregatesFilter
  BillingState: StringNullableWithAggregatesFilter
  CustomerId: IntWithAggregatesFilter
  InvoiceDate: DateTimeWithAggregatesFilter
  InvoiceId: IntWithAggregatesFilter
  NOT: [InvoiceScalarWhereWithAggregatesInput!]
  OR: [InvoiceScalarWhereWithAggregatesInput!]
  Total: DecimalWithAggregatesFilter
}

type InvoiceSumAggregate {
  CustomerId: Int
  InvoiceId: Int
  Total: Decimal
}

input InvoiceSumOrderByAggregateInput {
  CustomerId: SortOrder
  InvoiceId: SortOrder
  Total: SortOrder
}

input InvoiceUpdateInput {
  BillingAddress: NullableStringFieldUpdateOperationsInput
  BillingCity: NullableStringFieldUpdateOperationsInput
  BillingCountry: NullableStringFieldUpdateOperationsInput
  BillingPostalCode: NullableStringFieldUpdateOperationsInput
  BillingState: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateOneRequiredWithoutInvoiceNestedInput
  InvoiceDate: DateTimeFieldUpdateOperationsInput
  InvoiceId: IntFieldUpdateOperationsInput
  InvoiceLine: InvoiceLineUpdateManyWithoutInvoiceNestedInput
  Total: DecimalFieldUpdateOperationsInput
}

input InvoiceUpdateManyMutationInput {
  BillingAddress: NullableStringFieldUpdateOperationsInput
  BillingCity: NullableStringFieldUpdateOperationsInput
  BillingCountry: NullableStringFieldUpdateOperationsInput
  BillingPostalCode: NullableStringFieldUpdateOperationsInput
  BillingState: NullableStringFieldUpdateOperationsInput
  InvoiceDate: DateTimeFieldUpdateOperationsInput
  InvoiceId: IntFieldUpdateOperationsInput
  Total: DecimalFieldUpdateOperationsInput
}

input InvoiceUpdateManyWithWhereWithoutCustomerInput {
  data: InvoiceUpdateManyMutationInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateManyWithoutCustomerNestedInput {
  connect: [InvoiceWhereUniqueInput!]
  connectOrCreate: [InvoiceCreateOrConnectWithoutCustomerInput!]
  create: [InvoiceCreateWithoutCustomerInput!]
  createMany: InvoiceCreateManyCustomerInputEnvelope
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [InvoiceUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutCustomerInput!]
}

input InvoiceUpdateOneRequiredWithoutInvoiceLineNestedInput {
  connect: InvoiceWhereUniqueInput
  connectOrCreate: InvoiceCreateOrConnectWithoutInvoiceLineInput
  create: InvoiceCreateWithoutInvoiceLineInput
  update: InvoiceUpdateWithoutInvoiceLineInput
  upsert: InvoiceUpsertWithoutInvoiceLineInput
}

input InvoiceUpdateWithWhereUniqueWithoutCustomerInput {
  data: InvoiceUpdateWithoutCustomerInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithoutCustomerInput {
  BillingAddress: NullableStringFieldUpdateOperationsInput
  BillingCity: NullableStringFieldUpdateOperationsInput
  BillingCountry: NullableStringFieldUpdateOperationsInput
  BillingPostalCode: NullableStringFieldUpdateOperationsInput
  BillingState: NullableStringFieldUpdateOperationsInput
  InvoiceDate: DateTimeFieldUpdateOperationsInput
  InvoiceId: IntFieldUpdateOperationsInput
  InvoiceLine: InvoiceLineUpdateManyWithoutInvoiceNestedInput
  Total: DecimalFieldUpdateOperationsInput
}

input InvoiceUpdateWithoutInvoiceLineInput {
  BillingAddress: NullableStringFieldUpdateOperationsInput
  BillingCity: NullableStringFieldUpdateOperationsInput
  BillingCountry: NullableStringFieldUpdateOperationsInput
  BillingPostalCode: NullableStringFieldUpdateOperationsInput
  BillingState: NullableStringFieldUpdateOperationsInput
  Customer: CustomerUpdateOneRequiredWithoutInvoiceNestedInput
  InvoiceDate: DateTimeFieldUpdateOperationsInput
  InvoiceId: IntFieldUpdateOperationsInput
  Total: DecimalFieldUpdateOperationsInput
}

input InvoiceUpsertWithWhereUniqueWithoutCustomerInput {
  create: InvoiceCreateWithoutCustomerInput!
  update: InvoiceUpdateWithoutCustomerInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertWithoutInvoiceLineInput {
  create: InvoiceCreateWithoutInvoiceLineInput!
  update: InvoiceUpdateWithoutInvoiceLineInput!
}

input InvoiceWhereInput {
  AND: [InvoiceWhereInput!]
  BillingAddress: StringNullableFilter
  BillingCity: StringNullableFilter
  BillingCountry: StringNullableFilter
  BillingPostalCode: StringNullableFilter
  BillingState: StringNullableFilter
  Customer: CustomerRelationFilter
  CustomerId: IntFilter
  InvoiceDate: DateTimeFilter
  InvoiceId: IntFilter
  InvoiceLine: InvoiceLineListRelationFilter
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  Total: DecimalFilter
}

input InvoiceWhereUniqueInput {
  InvoiceId: Int
}

type MediaType {
  MediaTypeId: Int!
  Name: String
  Track(cursor: TrackWhereUniqueInput, distinct: [TrackScalarFieldEnum!], orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): [Track!]!
  _count: MediaTypeCount
}

type MediaTypeAvgAggregate {
  MediaTypeId: Float
}

input MediaTypeAvgOrderByAggregateInput {
  MediaTypeId: SortOrder
}

type MediaTypeCount {
  Track: Int!
}

type MediaTypeCountAggregate {
  MediaTypeId: Int!
  Name: Int!
  _all: Int!
}

input MediaTypeCountOrderByAggregateInput {
  MediaTypeId: SortOrder
  Name: SortOrder
}

input MediaTypeCreateInput {
  MediaTypeId: Int!
  Name: String
  Track: TrackCreateNestedManyWithoutMediaTypeInput
}

input MediaTypeCreateManyInput {
  MediaTypeId: Int!
  Name: String
}

input MediaTypeCreateNestedOneWithoutTrackInput {
  connect: MediaTypeWhereUniqueInput
  connectOrCreate: MediaTypeCreateOrConnectWithoutTrackInput
  create: MediaTypeCreateWithoutTrackInput
}

input MediaTypeCreateOrConnectWithoutTrackInput {
  create: MediaTypeCreateWithoutTrackInput!
  where: MediaTypeWhereUniqueInput!
}

input MediaTypeCreateWithoutTrackInput {
  MediaTypeId: Int!
  Name: String
}

type MediaTypeGroupBy {
  MediaTypeId: Int!
  Name: String
  _avg: MediaTypeAvgAggregate
  _count: MediaTypeCountAggregate
  _max: MediaTypeMaxAggregate
  _min: MediaTypeMinAggregate
  _sum: MediaTypeSumAggregate
}

type MediaTypeMaxAggregate {
  MediaTypeId: Int
  Name: String
}

input MediaTypeMaxOrderByAggregateInput {
  MediaTypeId: SortOrder
  Name: SortOrder
}

type MediaTypeMinAggregate {
  MediaTypeId: Int
  Name: String
}

input MediaTypeMinOrderByAggregateInput {
  MediaTypeId: SortOrder
  Name: SortOrder
}

input MediaTypeOrderByWithAggregationInput {
  MediaTypeId: SortOrder
  Name: SortOrder
  _avg: MediaTypeAvgOrderByAggregateInput
  _count: MediaTypeCountOrderByAggregateInput
  _max: MediaTypeMaxOrderByAggregateInput
  _min: MediaTypeMinOrderByAggregateInput
  _sum: MediaTypeSumOrderByAggregateInput
}

input MediaTypeOrderByWithRelationInput {
  MediaTypeId: SortOrder
  Name: SortOrder
  Track: TrackOrderByRelationAggregateInput
}

input MediaTypeRelationFilter {
  is: MediaTypeWhereInput
  isNot: MediaTypeWhereInput
}

enum MediaTypeScalarFieldEnum {
  MediaTypeId
  Name
}

input MediaTypeScalarWhereWithAggregatesInput {
  AND: [MediaTypeScalarWhereWithAggregatesInput!]
  MediaTypeId: IntWithAggregatesFilter
  NOT: [MediaTypeScalarWhereWithAggregatesInput!]
  Name: StringNullableWithAggregatesFilter
  OR: [MediaTypeScalarWhereWithAggregatesInput!]
}

type MediaTypeSumAggregate {
  MediaTypeId: Int
}

input MediaTypeSumOrderByAggregateInput {
  MediaTypeId: SortOrder
}

input MediaTypeUpdateInput {
  MediaTypeId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
  Track: TrackUpdateManyWithoutMediaTypeNestedInput
}

input MediaTypeUpdateManyMutationInput {
  MediaTypeId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input MediaTypeUpdateOneRequiredWithoutTrackNestedInput {
  connect: MediaTypeWhereUniqueInput
  connectOrCreate: MediaTypeCreateOrConnectWithoutTrackInput
  create: MediaTypeCreateWithoutTrackInput
  update: MediaTypeUpdateWithoutTrackInput
  upsert: MediaTypeUpsertWithoutTrackInput
}

input MediaTypeUpdateWithoutTrackInput {
  MediaTypeId: IntFieldUpdateOperationsInput
  Name: NullableStringFieldUpdateOperationsInput
}

input MediaTypeUpsertWithoutTrackInput {
  create: MediaTypeCreateWithoutTrackInput!
  update: MediaTypeUpdateWithoutTrackInput!
}

input MediaTypeWhereInput {
  AND: [MediaTypeWhereInput!]
  MediaTypeId: IntFilter
  NOT: [MediaTypeWhereInput!]
  Name: StringNullableFilter
  OR: [MediaTypeWhereInput!]
  Track: TrackListRelationFilter
}

input MediaTypeWhereUniqueInput {
  MediaTypeId: Int
}

type Mutation {
  createManyAlbum(data: [AlbumCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyArtist(data: [ArtistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCustomer(data: [CustomerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEmployee(data: [EmployeeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyGenre(data: [GenreCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInvoice(data: [InvoiceCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInvoiceLine(data: [InvoiceLineCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMediaType(data: [MediaTypeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPlaylist(data: [PlaylistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPlaylistTrack(data: [PlaylistTrackCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTrack(data: [TrackCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAlbum(data: AlbumCreateInput!): Album!
  createOneArtist(data: ArtistCreateInput!): Artist!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneGenre(data: GenreCreateInput!): Genre!
  createOneInvoice(data: InvoiceCreateInput!): Invoice!
  createOneInvoiceLine(data: InvoiceLineCreateInput!): InvoiceLine!
  createOneMediaType(data: MediaTypeCreateInput!): MediaType!
  createOnePlaylist(data: PlaylistCreateInput!): Playlist!
  createOnePlaylistTrack(data: PlaylistTrackCreateInput!): PlaylistTrack!
  createOneTrack(data: TrackCreateInput!): Track!
  deleteManyAlbum(where: AlbumWhereInput): AffectedRowsOutput!
  deleteManyArtist(where: ArtistWhereInput): AffectedRowsOutput!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyEmployee(where: EmployeeWhereInput): AffectedRowsOutput!
  deleteManyGenre(where: GenreWhereInput): AffectedRowsOutput!
  deleteManyInvoice(where: InvoiceWhereInput): AffectedRowsOutput!
  deleteManyInvoiceLine(where: InvoiceLineWhereInput): AffectedRowsOutput!
  deleteManyMediaType(where: MediaTypeWhereInput): AffectedRowsOutput!
  deleteManyPlaylist(where: PlaylistWhereInput): AffectedRowsOutput!
  deleteManyPlaylistTrack(where: PlaylistTrackWhereInput): AffectedRowsOutput!
  deleteManyTrack(where: TrackWhereInput): AffectedRowsOutput!
  deleteOneAlbum(where: AlbumWhereUniqueInput!): Album
  deleteOneArtist(where: ArtistWhereUniqueInput!): Artist
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteOneGenre(where: GenreWhereUniqueInput!): Genre
  deleteOneInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteOneInvoiceLine(where: InvoiceLineWhereUniqueInput!): InvoiceLine
  deleteOneMediaType(where: MediaTypeWhereUniqueInput!): MediaType
  deleteOnePlaylist(where: PlaylistWhereUniqueInput!): Playlist
  deleteOnePlaylistTrack(where: PlaylistTrackWhereUniqueInput!): PlaylistTrack
  deleteOneTrack(where: TrackWhereUniqueInput!): Track
  updateManyAlbum(data: AlbumUpdateManyMutationInput!, where: AlbumWhereInput): AffectedRowsOutput!
  updateManyArtist(data: ArtistUpdateManyMutationInput!, where: ArtistWhereInput): AffectedRowsOutput!
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyEmployee(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): AffectedRowsOutput!
  updateManyGenre(data: GenreUpdateManyMutationInput!, where: GenreWhereInput): AffectedRowsOutput!
  updateManyInvoice(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): AffectedRowsOutput!
  updateManyInvoiceLine(data: InvoiceLineUpdateManyMutationInput!, where: InvoiceLineWhereInput): AffectedRowsOutput!
  updateManyMediaType(data: MediaTypeUpdateManyMutationInput!, where: MediaTypeWhereInput): AffectedRowsOutput!
  updateManyPlaylist(data: PlaylistUpdateManyMutationInput!, where: PlaylistWhereInput): AffectedRowsOutput!
  updateManyPlaylistTrack(data: PlaylistTrackUpdateManyMutationInput!, where: PlaylistTrackWhereInput): AffectedRowsOutput!
  updateManyTrack(data: TrackUpdateManyMutationInput!, where: TrackWhereInput): AffectedRowsOutput!
  updateOneAlbum(data: AlbumUpdateInput!, where: AlbumWhereUniqueInput!): Album
  updateOneArtist(data: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneGenre(data: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre
  updateOneInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateOneInvoiceLine(data: InvoiceLineUpdateInput!, where: InvoiceLineWhereUniqueInput!): InvoiceLine
  updateOneMediaType(data: MediaTypeUpdateInput!, where: MediaTypeWhereUniqueInput!): MediaType
  updateOnePlaylist(data: PlaylistUpdateInput!, where: PlaylistWhereUniqueInput!): Playlist
  updateOnePlaylistTrack(data: PlaylistTrackUpdateInput!, where: PlaylistTrackWhereUniqueInput!): PlaylistTrack
  updateOneTrack(data: TrackUpdateInput!, where: TrackWhereUniqueInput!): Track
  upsertOneAlbum(create: AlbumCreateInput!, update: AlbumUpdateInput!, where: AlbumWhereUniqueInput!): Album!
  upsertOneArtist(create: ArtistCreateInput!, update: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist!
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOneGenre(create: GenreCreateInput!, update: GenreUpdateInput!, where: GenreWhereUniqueInput!): Genre!
  upsertOneInvoice(create: InvoiceCreateInput!, update: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice!
  upsertOneInvoiceLine(create: InvoiceLineCreateInput!, update: InvoiceLineUpdateInput!, where: InvoiceLineWhereUniqueInput!): InvoiceLine!
  upsertOneMediaType(create: MediaTypeCreateInput!, update: MediaTypeUpdateInput!, where: MediaTypeWhereUniqueInput!): MediaType!
  upsertOnePlaylist(create: PlaylistCreateInput!, update: PlaylistUpdateInput!, where: PlaylistWhereUniqueInput!): Playlist!
  upsertOnePlaylistTrack(create: PlaylistTrackCreateInput!, update: PlaylistTrackUpdateInput!, where: PlaylistTrackWhereUniqueInput!): PlaylistTrack!
  upsertOneTrack(create: TrackCreateInput!, update: TrackUpdateInput!, where: TrackWhereUniqueInput!): Track!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Playlist {
  Name: String
  PlaylistId: Int!
  PlaylistTrack(cursor: PlaylistTrackWhereUniqueInput, distinct: [PlaylistTrackScalarFieldEnum!], orderBy: [PlaylistTrackOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): [PlaylistTrack!]!
  _count: PlaylistCount
}

type PlaylistAvgAggregate {
  PlaylistId: Float
}

input PlaylistAvgOrderByAggregateInput {
  PlaylistId: SortOrder
}

type PlaylistCount {
  PlaylistTrack: Int!
}

type PlaylistCountAggregate {
  Name: Int!
  PlaylistId: Int!
  _all: Int!
}

input PlaylistCountOrderByAggregateInput {
  Name: SortOrder
  PlaylistId: SortOrder
}

input PlaylistCreateInput {
  Name: String
  PlaylistId: Int!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutPlaylistInput
}

input PlaylistCreateManyInput {
  Name: String
  PlaylistId: Int!
}

input PlaylistCreateNestedOneWithoutPlaylistTrackInput {
  connect: PlaylistWhereUniqueInput
  connectOrCreate: PlaylistCreateOrConnectWithoutPlaylistTrackInput
  create: PlaylistCreateWithoutPlaylistTrackInput
}

input PlaylistCreateOrConnectWithoutPlaylistTrackInput {
  create: PlaylistCreateWithoutPlaylistTrackInput!
  where: PlaylistWhereUniqueInput!
}

input PlaylistCreateWithoutPlaylistTrackInput {
  Name: String
  PlaylistId: Int!
}

type PlaylistGroupBy {
  Name: String
  PlaylistId: Int!
  _avg: PlaylistAvgAggregate
  _count: PlaylistCountAggregate
  _max: PlaylistMaxAggregate
  _min: PlaylistMinAggregate
  _sum: PlaylistSumAggregate
}

type PlaylistMaxAggregate {
  Name: String
  PlaylistId: Int
}

input PlaylistMaxOrderByAggregateInput {
  Name: SortOrder
  PlaylistId: SortOrder
}

type PlaylistMinAggregate {
  Name: String
  PlaylistId: Int
}

input PlaylistMinOrderByAggregateInput {
  Name: SortOrder
  PlaylistId: SortOrder
}

input PlaylistOrderByWithAggregationInput {
  Name: SortOrder
  PlaylistId: SortOrder
  _avg: PlaylistAvgOrderByAggregateInput
  _count: PlaylistCountOrderByAggregateInput
  _max: PlaylistMaxOrderByAggregateInput
  _min: PlaylistMinOrderByAggregateInput
  _sum: PlaylistSumOrderByAggregateInput
}

input PlaylistOrderByWithRelationInput {
  Name: SortOrder
  PlaylistId: SortOrder
  PlaylistTrack: PlaylistTrackOrderByRelationAggregateInput
}

input PlaylistRelationFilter {
  is: PlaylistWhereInput
  isNot: PlaylistWhereInput
}

enum PlaylistScalarFieldEnum {
  Name
  PlaylistId
}

input PlaylistScalarWhereWithAggregatesInput {
  AND: [PlaylistScalarWhereWithAggregatesInput!]
  NOT: [PlaylistScalarWhereWithAggregatesInput!]
  Name: StringNullableWithAggregatesFilter
  OR: [PlaylistScalarWhereWithAggregatesInput!]
  PlaylistId: IntWithAggregatesFilter
}

type PlaylistSumAggregate {
  PlaylistId: Int
}

input PlaylistSumOrderByAggregateInput {
  PlaylistId: SortOrder
}

type PlaylistTrack {
  PlayListTrackId: String
  Playlist: Playlist!
  PlaylistId: Int!
  Track: Track!
  TrackId: Int!
}

type PlaylistTrackAvgAggregate {
  PlaylistId: Float
  TrackId: Float
}

input PlaylistTrackAvgOrderByAggregateInput {
  PlaylistId: SortOrder
  TrackId: SortOrder
}

type PlaylistTrackCountAggregate {
  PlayListTrackId: Int!
  PlaylistId: Int!
  TrackId: Int!
  _all: Int!
}

input PlaylistTrackCountOrderByAggregateInput {
  PlayListTrackId: SortOrder
  PlaylistId: SortOrder
  TrackId: SortOrder
}

input PlaylistTrackCreateInput {
  PlayListTrackId: String
  Playlist: PlaylistCreateNestedOneWithoutPlaylistTrackInput!
  Track: TrackCreateNestedOneWithoutPlaylistTrackInput!
}

input PlaylistTrackCreateManyInput {
  PlayListTrackId: String
  PlaylistId: Int!
  TrackId: Int!
}

input PlaylistTrackCreateManyPlaylistInput {
  PlayListTrackId: String
  TrackId: Int!
}

input PlaylistTrackCreateManyPlaylistInputEnvelope {
  data: [PlaylistTrackCreateManyPlaylistInput!]!
  skipDuplicates: Boolean
}

input PlaylistTrackCreateManyTrackInput {
  PlayListTrackId: String
  PlaylistId: Int!
}

input PlaylistTrackCreateManyTrackInputEnvelope {
  data: [PlaylistTrackCreateManyTrackInput!]!
  skipDuplicates: Boolean
}

input PlaylistTrackCreateNestedManyWithoutPlaylistInput {
  connect: [PlaylistTrackWhereUniqueInput!]
  connectOrCreate: [PlaylistTrackCreateOrConnectWithoutPlaylistInput!]
  create: [PlaylistTrackCreateWithoutPlaylistInput!]
  createMany: PlaylistTrackCreateManyPlaylistInputEnvelope
}

input PlaylistTrackCreateNestedManyWithoutTrackInput {
  connect: [PlaylistTrackWhereUniqueInput!]
  connectOrCreate: [PlaylistTrackCreateOrConnectWithoutTrackInput!]
  create: [PlaylistTrackCreateWithoutTrackInput!]
  createMany: PlaylistTrackCreateManyTrackInputEnvelope
}

input PlaylistTrackCreateOrConnectWithoutPlaylistInput {
  create: PlaylistTrackCreateWithoutPlaylistInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackCreateOrConnectWithoutTrackInput {
  create: PlaylistTrackCreateWithoutTrackInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackCreateWithoutPlaylistInput {
  PlayListTrackId: String
  Track: TrackCreateNestedOneWithoutPlaylistTrackInput!
}

input PlaylistTrackCreateWithoutTrackInput {
  PlayListTrackId: String
  Playlist: PlaylistCreateNestedOneWithoutPlaylistTrackInput!
}

type PlaylistTrackGroupBy {
  PlayListTrackId: String
  PlaylistId: Int!
  TrackId: Int!
  _avg: PlaylistTrackAvgAggregate
  _count: PlaylistTrackCountAggregate
  _max: PlaylistTrackMaxAggregate
  _min: PlaylistTrackMinAggregate
  _sum: PlaylistTrackSumAggregate
}

input PlaylistTrackListRelationFilter {
  every: PlaylistTrackWhereInput
  none: PlaylistTrackWhereInput
  some: PlaylistTrackWhereInput
}

type PlaylistTrackMaxAggregate {
  PlayListTrackId: String
  PlaylistId: Int
  TrackId: Int
}

input PlaylistTrackMaxOrderByAggregateInput {
  PlayListTrackId: SortOrder
  PlaylistId: SortOrder
  TrackId: SortOrder
}

type PlaylistTrackMinAggregate {
  PlayListTrackId: String
  PlaylistId: Int
  TrackId: Int
}

input PlaylistTrackMinOrderByAggregateInput {
  PlayListTrackId: SortOrder
  PlaylistId: SortOrder
  TrackId: SortOrder
}

input PlaylistTrackOrderByRelationAggregateInput {
  _count: SortOrder
}

input PlaylistTrackOrderByWithAggregationInput {
  PlayListTrackId: SortOrder
  PlaylistId: SortOrder
  TrackId: SortOrder
  _avg: PlaylistTrackAvgOrderByAggregateInput
  _count: PlaylistTrackCountOrderByAggregateInput
  _max: PlaylistTrackMaxOrderByAggregateInput
  _min: PlaylistTrackMinOrderByAggregateInput
  _sum: PlaylistTrackSumOrderByAggregateInput
}

input PlaylistTrackOrderByWithRelationInput {
  PlayListTrackId: SortOrder
  Playlist: PlaylistOrderByWithRelationInput
  PlaylistId: SortOrder
  Track: TrackOrderByWithRelationInput
  TrackId: SortOrder
}

input PlaylistTrackPlaylistIdTrackIdCompoundUniqueInput {
  PlaylistId: Int!
  TrackId: Int!
}

enum PlaylistTrackScalarFieldEnum {
  PlayListTrackId
  PlaylistId
  TrackId
}

input PlaylistTrackScalarWhereInput {
  AND: [PlaylistTrackScalarWhereInput!]
  NOT: [PlaylistTrackScalarWhereInput!]
  OR: [PlaylistTrackScalarWhereInput!]
  PlayListTrackId: StringNullableFilter
  PlaylistId: IntFilter
  TrackId: IntFilter
}

input PlaylistTrackScalarWhereWithAggregatesInput {
  AND: [PlaylistTrackScalarWhereWithAggregatesInput!]
  NOT: [PlaylistTrackScalarWhereWithAggregatesInput!]
  OR: [PlaylistTrackScalarWhereWithAggregatesInput!]
  PlayListTrackId: StringNullableWithAggregatesFilter
  PlaylistId: IntWithAggregatesFilter
  TrackId: IntWithAggregatesFilter
}

type PlaylistTrackSumAggregate {
  PlaylistId: Int
  TrackId: Int
}

input PlaylistTrackSumOrderByAggregateInput {
  PlaylistId: SortOrder
  TrackId: SortOrder
}

input PlaylistTrackUpdateInput {
  PlayListTrackId: NullableStringFieldUpdateOperationsInput
  Playlist: PlaylistUpdateOneRequiredWithoutPlaylistTrackNestedInput
  Track: TrackUpdateOneRequiredWithoutPlaylistTrackNestedInput
}

input PlaylistTrackUpdateManyMutationInput {
  PlayListTrackId: NullableStringFieldUpdateOperationsInput
}

input PlaylistTrackUpdateManyWithWhereWithoutPlaylistInput {
  data: PlaylistTrackUpdateManyMutationInput!
  where: PlaylistTrackScalarWhereInput!
}

input PlaylistTrackUpdateManyWithWhereWithoutTrackInput {
  data: PlaylistTrackUpdateManyMutationInput!
  where: PlaylistTrackScalarWhereInput!
}

input PlaylistTrackUpdateManyWithoutPlaylistNestedInput {
  connect: [PlaylistTrackWhereUniqueInput!]
  connectOrCreate: [PlaylistTrackCreateOrConnectWithoutPlaylistInput!]
  create: [PlaylistTrackCreateWithoutPlaylistInput!]
  createMany: PlaylistTrackCreateManyPlaylistInputEnvelope
  delete: [PlaylistTrackWhereUniqueInput!]
  deleteMany: [PlaylistTrackScalarWhereInput!]
  disconnect: [PlaylistTrackWhereUniqueInput!]
  set: [PlaylistTrackWhereUniqueInput!]
  update: [PlaylistTrackUpdateWithWhereUniqueWithoutPlaylistInput!]
  updateMany: [PlaylistTrackUpdateManyWithWhereWithoutPlaylistInput!]
  upsert: [PlaylistTrackUpsertWithWhereUniqueWithoutPlaylistInput!]
}

input PlaylistTrackUpdateManyWithoutTrackNestedInput {
  connect: [PlaylistTrackWhereUniqueInput!]
  connectOrCreate: [PlaylistTrackCreateOrConnectWithoutTrackInput!]
  create: [PlaylistTrackCreateWithoutTrackInput!]
  createMany: PlaylistTrackCreateManyTrackInputEnvelope
  delete: [PlaylistTrackWhereUniqueInput!]
  deleteMany: [PlaylistTrackScalarWhereInput!]
  disconnect: [PlaylistTrackWhereUniqueInput!]
  set: [PlaylistTrackWhereUniqueInput!]
  update: [PlaylistTrackUpdateWithWhereUniqueWithoutTrackInput!]
  updateMany: [PlaylistTrackUpdateManyWithWhereWithoutTrackInput!]
  upsert: [PlaylistTrackUpsertWithWhereUniqueWithoutTrackInput!]
}

input PlaylistTrackUpdateWithWhereUniqueWithoutPlaylistInput {
  data: PlaylistTrackUpdateWithoutPlaylistInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackUpdateWithWhereUniqueWithoutTrackInput {
  data: PlaylistTrackUpdateWithoutTrackInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackUpdateWithoutPlaylistInput {
  PlayListTrackId: NullableStringFieldUpdateOperationsInput
  Track: TrackUpdateOneRequiredWithoutPlaylistTrackNestedInput
}

input PlaylistTrackUpdateWithoutTrackInput {
  PlayListTrackId: NullableStringFieldUpdateOperationsInput
  Playlist: PlaylistUpdateOneRequiredWithoutPlaylistTrackNestedInput
}

input PlaylistTrackUpsertWithWhereUniqueWithoutPlaylistInput {
  create: PlaylistTrackCreateWithoutPlaylistInput!
  update: PlaylistTrackUpdateWithoutPlaylistInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackUpsertWithWhereUniqueWithoutTrackInput {
  create: PlaylistTrackCreateWithoutTrackInput!
  update: PlaylistTrackUpdateWithoutTrackInput!
  where: PlaylistTrackWhereUniqueInput!
}

input PlaylistTrackWhereInput {
  AND: [PlaylistTrackWhereInput!]
  NOT: [PlaylistTrackWhereInput!]
  OR: [PlaylistTrackWhereInput!]
  PlayListTrackId: StringNullableFilter
  Playlist: PlaylistRelationFilter
  PlaylistId: IntFilter
  Track: TrackRelationFilter
  TrackId: IntFilter
}

input PlaylistTrackWhereUniqueInput {
  PlayListTrackId: String
  PlaylistId_TrackId: PlaylistTrackPlaylistIdTrackIdCompoundUniqueInput
}

input PlaylistUpdateInput {
  Name: NullableStringFieldUpdateOperationsInput
  PlaylistId: IntFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutPlaylistNestedInput
}

input PlaylistUpdateManyMutationInput {
  Name: NullableStringFieldUpdateOperationsInput
  PlaylistId: IntFieldUpdateOperationsInput
}

input PlaylistUpdateOneRequiredWithoutPlaylistTrackNestedInput {
  connect: PlaylistWhereUniqueInput
  connectOrCreate: PlaylistCreateOrConnectWithoutPlaylistTrackInput
  create: PlaylistCreateWithoutPlaylistTrackInput
  update: PlaylistUpdateWithoutPlaylistTrackInput
  upsert: PlaylistUpsertWithoutPlaylistTrackInput
}

input PlaylistUpdateWithoutPlaylistTrackInput {
  Name: NullableStringFieldUpdateOperationsInput
  PlaylistId: IntFieldUpdateOperationsInput
}

input PlaylistUpsertWithoutPlaylistTrackInput {
  create: PlaylistCreateWithoutPlaylistTrackInput!
  update: PlaylistUpdateWithoutPlaylistTrackInput!
}

input PlaylistWhereInput {
  AND: [PlaylistWhereInput!]
  NOT: [PlaylistWhereInput!]
  Name: StringNullableFilter
  OR: [PlaylistWhereInput!]
  PlaylistId: IntFilter
  PlaylistTrack: PlaylistTrackListRelationFilter
}

input PlaylistWhereUniqueInput {
  PlaylistId: Int
}

type Query {
  aggregateAlbum(cursor: AlbumWhereUniqueInput, orderBy: [AlbumOrderByWithRelationInput!], skip: Int, take: Int, where: AlbumWhereInput): AggregateAlbum!
  aggregateArtist(cursor: ArtistWhereUniqueInput, orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): AggregateArtist!
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateEmployee(cursor: EmployeeWhereUniqueInput, orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): AggregateEmployee!
  aggregateGenre(cursor: GenreWhereUniqueInput, orderBy: [GenreOrderByWithRelationInput!], skip: Int, take: Int, where: GenreWhereInput): AggregateGenre!
  aggregateInvoice(cursor: InvoiceWhereUniqueInput, orderBy: [InvoiceOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceWhereInput): AggregateInvoice!
  aggregateInvoiceLine(cursor: InvoiceLineWhereUniqueInput, orderBy: [InvoiceLineOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): AggregateInvoiceLine!
  aggregateMediaType(cursor: MediaTypeWhereUniqueInput, orderBy: [MediaTypeOrderByWithRelationInput!], skip: Int, take: Int, where: MediaTypeWhereInput): AggregateMediaType!
  aggregatePlaylist(cursor: PlaylistWhereUniqueInput, orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): AggregatePlaylist!
  aggregatePlaylistTrack(cursor: PlaylistTrackWhereUniqueInput, orderBy: [PlaylistTrackOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): AggregatePlaylistTrack!
  aggregateTrack(cursor: TrackWhereUniqueInput, orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): AggregateTrack!
  album(where: AlbumWhereUniqueInput!): Album
  albums(cursor: AlbumWhereUniqueInput, distinct: [AlbumScalarFieldEnum!], orderBy: [AlbumOrderByWithRelationInput!], skip: Int, take: Int, where: AlbumWhereInput): [Album!]!
  artist(where: ArtistWhereUniqueInput!): Artist
  artists(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): [Artist!]!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  findFirstAlbum(cursor: AlbumWhereUniqueInput, distinct: [AlbumScalarFieldEnum!], orderBy: [AlbumOrderByWithRelationInput!], skip: Int, take: Int, where: AlbumWhereInput): Album
  findFirstArtist(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): Artist
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstEmployee(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstGenre(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationInput!], skip: Int, take: Int, where: GenreWhereInput): Genre
  findFirstInvoice(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceWhereInput): Invoice
  findFirstInvoiceLine(cursor: InvoiceLineWhereUniqueInput, distinct: [InvoiceLineScalarFieldEnum!], orderBy: [InvoiceLineOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): InvoiceLine
  findFirstMediaType(cursor: MediaTypeWhereUniqueInput, distinct: [MediaTypeScalarFieldEnum!], orderBy: [MediaTypeOrderByWithRelationInput!], skip: Int, take: Int, where: MediaTypeWhereInput): MediaType
  findFirstPlaylist(cursor: PlaylistWhereUniqueInput, distinct: [PlaylistScalarFieldEnum!], orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): Playlist
  findFirstPlaylistTrack(cursor: PlaylistTrackWhereUniqueInput, distinct: [PlaylistTrackScalarFieldEnum!], orderBy: [PlaylistTrackOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): PlaylistTrack
  findFirstTrack(cursor: TrackWhereUniqueInput, distinct: [TrackScalarFieldEnum!], orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): Track
  genre(where: GenreWhereUniqueInput!): Genre
  genres(cursor: GenreWhereUniqueInput, distinct: [GenreScalarFieldEnum!], orderBy: [GenreOrderByWithRelationInput!], skip: Int, take: Int, where: GenreWhereInput): [Genre!]!
  groupByAlbum(by: [AlbumScalarFieldEnum!]!, having: AlbumScalarWhereWithAggregatesInput, orderBy: [AlbumOrderByWithAggregationInput!], skip: Int, take: Int, where: AlbumWhereInput): [AlbumGroupBy!]!
  groupByArtist(by: [ArtistScalarFieldEnum!]!, having: ArtistScalarWhereWithAggregatesInput, orderBy: [ArtistOrderByWithAggregationInput!], skip: Int, take: Int, where: ArtistWhereInput): [ArtistGroupBy!]!
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByEmployee(by: [EmployeeScalarFieldEnum!]!, having: EmployeeScalarWhereWithAggregatesInput, orderBy: [EmployeeOrderByWithAggregationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [EmployeeGroupBy!]!
  groupByGenre(by: [GenreScalarFieldEnum!]!, having: GenreScalarWhereWithAggregatesInput, orderBy: [GenreOrderByWithAggregationInput!], skip: Int, take: Int, where: GenreWhereInput): [GenreGroupBy!]!
  groupByInvoice(by: [InvoiceScalarFieldEnum!]!, having: InvoiceScalarWhereWithAggregatesInput, orderBy: [InvoiceOrderByWithAggregationInput!], skip: Int, take: Int, where: InvoiceWhereInput): [InvoiceGroupBy!]!
  groupByInvoiceLine(by: [InvoiceLineScalarFieldEnum!]!, having: InvoiceLineScalarWhereWithAggregatesInput, orderBy: [InvoiceLineOrderByWithAggregationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): [InvoiceLineGroupBy!]!
  groupByMediaType(by: [MediaTypeScalarFieldEnum!]!, having: MediaTypeScalarWhereWithAggregatesInput, orderBy: [MediaTypeOrderByWithAggregationInput!], skip: Int, take: Int, where: MediaTypeWhereInput): [MediaTypeGroupBy!]!
  groupByPlaylist(by: [PlaylistScalarFieldEnum!]!, having: PlaylistScalarWhereWithAggregatesInput, orderBy: [PlaylistOrderByWithAggregationInput!], skip: Int, take: Int, where: PlaylistWhereInput): [PlaylistGroupBy!]!
  groupByPlaylistTrack(by: [PlaylistTrackScalarFieldEnum!]!, having: PlaylistTrackScalarWhereWithAggregatesInput, orderBy: [PlaylistTrackOrderByWithAggregationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): [PlaylistTrackGroupBy!]!
  groupByTrack(by: [TrackScalarFieldEnum!]!, having: TrackScalarWhereWithAggregatesInput, orderBy: [TrackOrderByWithAggregationInput!], skip: Int, take: Int, where: TrackWhereInput): [TrackGroupBy!]!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoiceLine(where: InvoiceLineWhereUniqueInput!): InvoiceLine
  invoiceLines(cursor: InvoiceLineWhereUniqueInput, distinct: [InvoiceLineScalarFieldEnum!], orderBy: [InvoiceLineOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): [InvoiceLine!]!
  invoices(cursor: InvoiceWhereUniqueInput, distinct: [InvoiceScalarFieldEnum!], orderBy: [InvoiceOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceWhereInput): [Invoice!]!
  mediaType(where: MediaTypeWhereUniqueInput!): MediaType
  mediaTypes(cursor: MediaTypeWhereUniqueInput, distinct: [MediaTypeScalarFieldEnum!], orderBy: [MediaTypeOrderByWithRelationInput!], skip: Int, take: Int, where: MediaTypeWhereInput): [MediaType!]!
  playlist(where: PlaylistWhereUniqueInput!): Playlist
  playlistTrack(where: PlaylistTrackWhereUniqueInput!): PlaylistTrack
  playlistTracks(cursor: PlaylistTrackWhereUniqueInput, distinct: [PlaylistTrackScalarFieldEnum!], orderBy: [PlaylistTrackOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): [PlaylistTrack!]!
  playlists(cursor: PlaylistWhereUniqueInput, distinct: [PlaylistScalarFieldEnum!], orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): [Playlist!]!
  track(where: TrackWhereUniqueInput!): Track
  tracks(cursor: TrackWhereUniqueInput, distinct: [TrackScalarFieldEnum!], orderBy: [TrackOrderByWithRelationInput!], skip: Int, take: Int, where: TrackWhereInput): [Track!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Track {
  Album: Album
  AlbumId: Int
  Bytes: Int
  Composer: String
  Genre: Genre
  GenreId: Int
  InvoiceLine(cursor: InvoiceLineWhereUniqueInput, distinct: [InvoiceLineScalarFieldEnum!], orderBy: [InvoiceLineOrderByWithRelationInput!], skip: Int, take: Int, where: InvoiceLineWhereInput): [InvoiceLine!]!
  MediaType: MediaType!
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: String!
  PlaylistTrack(cursor: PlaylistTrackWhereUniqueInput, distinct: [PlaylistTrackScalarFieldEnum!], orderBy: [PlaylistTrackOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistTrackWhereInput): [PlaylistTrack!]!
  TrackId: Int!
  UnitPrice: Decimal!
  _count: TrackCount
}

type TrackAvgAggregate {
  AlbumId: Float
  Bytes: Float
  GenreId: Float
  MediaTypeId: Float
  Milliseconds: Float
  TrackId: Float
  UnitPrice: Decimal
}

input TrackAvgOrderByAggregateInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

type TrackCount {
  InvoiceLine: Int!
  PlaylistTrack: Int!
}

type TrackCountAggregate {
  AlbumId: Int!
  Bytes: Int!
  Composer: Int!
  GenreId: Int!
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: Int!
  TrackId: Int!
  UnitPrice: Int!
  _all: Int!
}

input TrackCountOrderByAggregateInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  Composer: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  Name: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input TrackCreateInput {
  Album: AlbumCreateNestedOneWithoutTrackInput
  Bytes: Int
  Composer: String
  Genre: GenreCreateNestedOneWithoutTrackInput
  InvoiceLine: InvoiceLineCreateNestedManyWithoutTrackInput
  MediaType: MediaTypeCreateNestedOneWithoutTrackInput!
  Milliseconds: Int!
  Name: String!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutTrackInput
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateManyAlbumInput {
  Bytes: Int
  Composer: String
  GenreId: Int
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateManyAlbumInputEnvelope {
  data: [TrackCreateManyAlbumInput!]!
  skipDuplicates: Boolean
}

input TrackCreateManyGenreInput {
  AlbumId: Int
  Bytes: Int
  Composer: String
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateManyGenreInputEnvelope {
  data: [TrackCreateManyGenreInput!]!
  skipDuplicates: Boolean
}

input TrackCreateManyInput {
  AlbumId: Int
  Bytes: Int
  Composer: String
  GenreId: Int
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateManyMediaTypeInput {
  AlbumId: Int
  Bytes: Int
  Composer: String
  GenreId: Int
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateManyMediaTypeInputEnvelope {
  data: [TrackCreateManyMediaTypeInput!]!
  skipDuplicates: Boolean
}

input TrackCreateNestedManyWithoutAlbumInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutAlbumInput!]
  create: [TrackCreateWithoutAlbumInput!]
  createMany: TrackCreateManyAlbumInputEnvelope
}

input TrackCreateNestedManyWithoutGenreInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutGenreInput!]
  create: [TrackCreateWithoutGenreInput!]
  createMany: TrackCreateManyGenreInputEnvelope
}

input TrackCreateNestedManyWithoutMediaTypeInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutMediaTypeInput!]
  create: [TrackCreateWithoutMediaTypeInput!]
  createMany: TrackCreateManyMediaTypeInputEnvelope
}

input TrackCreateNestedOneWithoutInvoiceLineInput {
  connect: TrackWhereUniqueInput
  connectOrCreate: TrackCreateOrConnectWithoutInvoiceLineInput
  create: TrackCreateWithoutInvoiceLineInput
}

input TrackCreateNestedOneWithoutPlaylistTrackInput {
  connect: TrackWhereUniqueInput
  connectOrCreate: TrackCreateOrConnectWithoutPlaylistTrackInput
  create: TrackCreateWithoutPlaylistTrackInput
}

input TrackCreateOrConnectWithoutAlbumInput {
  create: TrackCreateWithoutAlbumInput!
  where: TrackWhereUniqueInput!
}

input TrackCreateOrConnectWithoutGenreInput {
  create: TrackCreateWithoutGenreInput!
  where: TrackWhereUniqueInput!
}

input TrackCreateOrConnectWithoutInvoiceLineInput {
  create: TrackCreateWithoutInvoiceLineInput!
  where: TrackWhereUniqueInput!
}

input TrackCreateOrConnectWithoutMediaTypeInput {
  create: TrackCreateWithoutMediaTypeInput!
  where: TrackWhereUniqueInput!
}

input TrackCreateOrConnectWithoutPlaylistTrackInput {
  create: TrackCreateWithoutPlaylistTrackInput!
  where: TrackWhereUniqueInput!
}

input TrackCreateWithoutAlbumInput {
  Bytes: Int
  Composer: String
  Genre: GenreCreateNestedOneWithoutTrackInput
  InvoiceLine: InvoiceLineCreateNestedManyWithoutTrackInput
  MediaType: MediaTypeCreateNestedOneWithoutTrackInput!
  Milliseconds: Int!
  Name: String!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutTrackInput
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateWithoutGenreInput {
  Album: AlbumCreateNestedOneWithoutTrackInput
  Bytes: Int
  Composer: String
  InvoiceLine: InvoiceLineCreateNestedManyWithoutTrackInput
  MediaType: MediaTypeCreateNestedOneWithoutTrackInput!
  Milliseconds: Int!
  Name: String!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutTrackInput
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateWithoutInvoiceLineInput {
  Album: AlbumCreateNestedOneWithoutTrackInput
  Bytes: Int
  Composer: String
  Genre: GenreCreateNestedOneWithoutTrackInput
  MediaType: MediaTypeCreateNestedOneWithoutTrackInput!
  Milliseconds: Int!
  Name: String!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutTrackInput
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateWithoutMediaTypeInput {
  Album: AlbumCreateNestedOneWithoutTrackInput
  Bytes: Int
  Composer: String
  Genre: GenreCreateNestedOneWithoutTrackInput
  InvoiceLine: InvoiceLineCreateNestedManyWithoutTrackInput
  Milliseconds: Int!
  Name: String!
  PlaylistTrack: PlaylistTrackCreateNestedManyWithoutTrackInput
  TrackId: Int!
  UnitPrice: Decimal!
}

input TrackCreateWithoutPlaylistTrackInput {
  Album: AlbumCreateNestedOneWithoutTrackInput
  Bytes: Int
  Composer: String
  Genre: GenreCreateNestedOneWithoutTrackInput
  InvoiceLine: InvoiceLineCreateNestedManyWithoutTrackInput
  MediaType: MediaTypeCreateNestedOneWithoutTrackInput!
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
}

type TrackGroupBy {
  AlbumId: Int
  Bytes: Int
  Composer: String
  GenreId: Int
  MediaTypeId: Int!
  Milliseconds: Int!
  Name: String!
  TrackId: Int!
  UnitPrice: Decimal!
  _avg: TrackAvgAggregate
  _count: TrackCountAggregate
  _max: TrackMaxAggregate
  _min: TrackMinAggregate
  _sum: TrackSumAggregate
}

input TrackListRelationFilter {
  every: TrackWhereInput
  none: TrackWhereInput
  some: TrackWhereInput
}

type TrackMaxAggregate {
  AlbumId: Int
  Bytes: Int
  Composer: String
  GenreId: Int
  MediaTypeId: Int
  Milliseconds: Int
  Name: String
  TrackId: Int
  UnitPrice: Decimal
}

input TrackMaxOrderByAggregateInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  Composer: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  Name: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

type TrackMinAggregate {
  AlbumId: Int
  Bytes: Int
  Composer: String
  GenreId: Int
  MediaTypeId: Int
  Milliseconds: Int
  Name: String
  TrackId: Int
  UnitPrice: Decimal
}

input TrackMinOrderByAggregateInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  Composer: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  Name: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input TrackOrderByRelationAggregateInput {
  _count: SortOrder
}

input TrackOrderByWithAggregationInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  Composer: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  Name: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
  _avg: TrackAvgOrderByAggregateInput
  _count: TrackCountOrderByAggregateInput
  _max: TrackMaxOrderByAggregateInput
  _min: TrackMinOrderByAggregateInput
  _sum: TrackSumOrderByAggregateInput
}

input TrackOrderByWithRelationInput {
  Album: AlbumOrderByWithRelationInput
  AlbumId: SortOrder
  Bytes: SortOrder
  Composer: SortOrder
  Genre: GenreOrderByWithRelationInput
  GenreId: SortOrder
  InvoiceLine: InvoiceLineOrderByRelationAggregateInput
  MediaType: MediaTypeOrderByWithRelationInput
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  Name: SortOrder
  PlaylistTrack: PlaylistTrackOrderByRelationAggregateInput
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input TrackRelationFilter {
  is: TrackWhereInput
  isNot: TrackWhereInput
}

enum TrackScalarFieldEnum {
  AlbumId
  Bytes
  Composer
  GenreId
  MediaTypeId
  Milliseconds
  Name
  TrackId
  UnitPrice
}

input TrackScalarWhereInput {
  AND: [TrackScalarWhereInput!]
  AlbumId: IntNullableFilter
  Bytes: IntNullableFilter
  Composer: StringNullableFilter
  GenreId: IntNullableFilter
  MediaTypeId: IntFilter
  Milliseconds: IntFilter
  NOT: [TrackScalarWhereInput!]
  Name: StringFilter
  OR: [TrackScalarWhereInput!]
  TrackId: IntFilter
  UnitPrice: DecimalFilter
}

input TrackScalarWhereWithAggregatesInput {
  AND: [TrackScalarWhereWithAggregatesInput!]
  AlbumId: IntNullableWithAggregatesFilter
  Bytes: IntNullableWithAggregatesFilter
  Composer: StringNullableWithAggregatesFilter
  GenreId: IntNullableWithAggregatesFilter
  MediaTypeId: IntWithAggregatesFilter
  Milliseconds: IntWithAggregatesFilter
  NOT: [TrackScalarWhereWithAggregatesInput!]
  Name: StringWithAggregatesFilter
  OR: [TrackScalarWhereWithAggregatesInput!]
  TrackId: IntWithAggregatesFilter
  UnitPrice: DecimalWithAggregatesFilter
}

type TrackSumAggregate {
  AlbumId: Int
  Bytes: Int
  GenreId: Int
  MediaTypeId: Int
  Milliseconds: Int
  TrackId: Int
  UnitPrice: Decimal
}

input TrackSumOrderByAggregateInput {
  AlbumId: SortOrder
  Bytes: SortOrder
  GenreId: SortOrder
  MediaTypeId: SortOrder
  Milliseconds: SortOrder
  TrackId: SortOrder
  UnitPrice: SortOrder
}

input TrackUpdateInput {
  Album: AlbumUpdateOneWithoutTrackNestedInput
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Genre: GenreUpdateOneWithoutTrackNestedInput
  InvoiceLine: InvoiceLineUpdateManyWithoutTrackNestedInput
  MediaType: MediaTypeUpdateOneRequiredWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutTrackNestedInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateManyMutationInput {
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateManyWithWhereWithoutAlbumInput {
  data: TrackUpdateManyMutationInput!
  where: TrackScalarWhereInput!
}

input TrackUpdateManyWithWhereWithoutGenreInput {
  data: TrackUpdateManyMutationInput!
  where: TrackScalarWhereInput!
}

input TrackUpdateManyWithWhereWithoutMediaTypeInput {
  data: TrackUpdateManyMutationInput!
  where: TrackScalarWhereInput!
}

input TrackUpdateManyWithoutAlbumNestedInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutAlbumInput!]
  create: [TrackCreateWithoutAlbumInput!]
  createMany: TrackCreateManyAlbumInputEnvelope
  delete: [TrackWhereUniqueInput!]
  deleteMany: [TrackScalarWhereInput!]
  disconnect: [TrackWhereUniqueInput!]
  set: [TrackWhereUniqueInput!]
  update: [TrackUpdateWithWhereUniqueWithoutAlbumInput!]
  updateMany: [TrackUpdateManyWithWhereWithoutAlbumInput!]
  upsert: [TrackUpsertWithWhereUniqueWithoutAlbumInput!]
}

input TrackUpdateManyWithoutGenreNestedInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutGenreInput!]
  create: [TrackCreateWithoutGenreInput!]
  createMany: TrackCreateManyGenreInputEnvelope
  delete: [TrackWhereUniqueInput!]
  deleteMany: [TrackScalarWhereInput!]
  disconnect: [TrackWhereUniqueInput!]
  set: [TrackWhereUniqueInput!]
  update: [TrackUpdateWithWhereUniqueWithoutGenreInput!]
  updateMany: [TrackUpdateManyWithWhereWithoutGenreInput!]
  upsert: [TrackUpsertWithWhereUniqueWithoutGenreInput!]
}

input TrackUpdateManyWithoutMediaTypeNestedInput {
  connect: [TrackWhereUniqueInput!]
  connectOrCreate: [TrackCreateOrConnectWithoutMediaTypeInput!]
  create: [TrackCreateWithoutMediaTypeInput!]
  createMany: TrackCreateManyMediaTypeInputEnvelope
  delete: [TrackWhereUniqueInput!]
  deleteMany: [TrackScalarWhereInput!]
  disconnect: [TrackWhereUniqueInput!]
  set: [TrackWhereUniqueInput!]
  update: [TrackUpdateWithWhereUniqueWithoutMediaTypeInput!]
  updateMany: [TrackUpdateManyWithWhereWithoutMediaTypeInput!]
  upsert: [TrackUpsertWithWhereUniqueWithoutMediaTypeInput!]
}

input TrackUpdateOneRequiredWithoutInvoiceLineNestedInput {
  connect: TrackWhereUniqueInput
  connectOrCreate: TrackCreateOrConnectWithoutInvoiceLineInput
  create: TrackCreateWithoutInvoiceLineInput
  update: TrackUpdateWithoutInvoiceLineInput
  upsert: TrackUpsertWithoutInvoiceLineInput
}

input TrackUpdateOneRequiredWithoutPlaylistTrackNestedInput {
  connect: TrackWhereUniqueInput
  connectOrCreate: TrackCreateOrConnectWithoutPlaylistTrackInput
  create: TrackCreateWithoutPlaylistTrackInput
  update: TrackUpdateWithoutPlaylistTrackInput
  upsert: TrackUpsertWithoutPlaylistTrackInput
}

input TrackUpdateWithWhereUniqueWithoutAlbumInput {
  data: TrackUpdateWithoutAlbumInput!
  where: TrackWhereUniqueInput!
}

input TrackUpdateWithWhereUniqueWithoutGenreInput {
  data: TrackUpdateWithoutGenreInput!
  where: TrackWhereUniqueInput!
}

input TrackUpdateWithWhereUniqueWithoutMediaTypeInput {
  data: TrackUpdateWithoutMediaTypeInput!
  where: TrackWhereUniqueInput!
}

input TrackUpdateWithoutAlbumInput {
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Genre: GenreUpdateOneWithoutTrackNestedInput
  InvoiceLine: InvoiceLineUpdateManyWithoutTrackNestedInput
  MediaType: MediaTypeUpdateOneRequiredWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutTrackNestedInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateWithoutGenreInput {
  Album: AlbumUpdateOneWithoutTrackNestedInput
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  InvoiceLine: InvoiceLineUpdateManyWithoutTrackNestedInput
  MediaType: MediaTypeUpdateOneRequiredWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutTrackNestedInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateWithoutInvoiceLineInput {
  Album: AlbumUpdateOneWithoutTrackNestedInput
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Genre: GenreUpdateOneWithoutTrackNestedInput
  MediaType: MediaTypeUpdateOneRequiredWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutTrackNestedInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateWithoutMediaTypeInput {
  Album: AlbumUpdateOneWithoutTrackNestedInput
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Genre: GenreUpdateOneWithoutTrackNestedInput
  InvoiceLine: InvoiceLineUpdateManyWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  PlaylistTrack: PlaylistTrackUpdateManyWithoutTrackNestedInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpdateWithoutPlaylistTrackInput {
  Album: AlbumUpdateOneWithoutTrackNestedInput
  Bytes: NullableIntFieldUpdateOperationsInput
  Composer: NullableStringFieldUpdateOperationsInput
  Genre: GenreUpdateOneWithoutTrackNestedInput
  InvoiceLine: InvoiceLineUpdateManyWithoutTrackNestedInput
  MediaType: MediaTypeUpdateOneRequiredWithoutTrackNestedInput
  Milliseconds: IntFieldUpdateOperationsInput
  Name: StringFieldUpdateOperationsInput
  TrackId: IntFieldUpdateOperationsInput
  UnitPrice: DecimalFieldUpdateOperationsInput
}

input TrackUpsertWithWhereUniqueWithoutAlbumInput {
  create: TrackCreateWithoutAlbumInput!
  update: TrackUpdateWithoutAlbumInput!
  where: TrackWhereUniqueInput!
}

input TrackUpsertWithWhereUniqueWithoutGenreInput {
  create: TrackCreateWithoutGenreInput!
  update: TrackUpdateWithoutGenreInput!
  where: TrackWhereUniqueInput!
}

input TrackUpsertWithWhereUniqueWithoutMediaTypeInput {
  create: TrackCreateWithoutMediaTypeInput!
  update: TrackUpdateWithoutMediaTypeInput!
  where: TrackWhereUniqueInput!
}

input TrackUpsertWithoutInvoiceLineInput {
  create: TrackCreateWithoutInvoiceLineInput!
  update: TrackUpdateWithoutInvoiceLineInput!
}

input TrackUpsertWithoutPlaylistTrackInput {
  create: TrackCreateWithoutPlaylistTrackInput!
  update: TrackUpdateWithoutPlaylistTrackInput!
}

input TrackWhereInput {
  AND: [TrackWhereInput!]
  Album: AlbumRelationFilter
  AlbumId: IntNullableFilter
  Bytes: IntNullableFilter
  Composer: StringNullableFilter
  Genre: GenreRelationFilter
  GenreId: IntNullableFilter
  InvoiceLine: InvoiceLineListRelationFilter
  MediaType: MediaTypeRelationFilter
  MediaTypeId: IntFilter
  Milliseconds: IntFilter
  NOT: [TrackWhereInput!]
  Name: StringFilter
  OR: [TrackWhereInput!]
  PlaylistTrack: PlaylistTrackListRelationFilter
  TrackId: IntFilter
  UnitPrice: DecimalFilter
}

input TrackWhereUniqueInput {
  TrackId: Int
}
