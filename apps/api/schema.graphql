# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAward {
  _avg: AwardAvgAggregate
  _count: AwardCountAggregate
  _max: AwardMaxAggregate
  _min: AwardMinAggregate
  _sum: AwardSumAggregate
}

type AggregateEducation {
  _avg: EducationAvgAggregate
  _count: EducationCountAggregate
  _max: EducationMaxAggregate
  _min: EducationMinAggregate
  _sum: EducationSumAggregate
}

type AggregateInterest {
  _avg: InterestAvgAggregate
  _count: InterestCountAggregate
  _max: InterestMaxAggregate
  _min: InterestMinAggregate
  _sum: InterestSumAggregate
}

type AggregateLanguage {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
}

type AggregateLocation {
  _avg: LocationAvgAggregate
  _count: LocationCountAggregate
  _max: LocationMaxAggregate
  _min: LocationMinAggregate
  _sum: LocationSumAggregate
}

type AggregateNestedProjectLevel1 {
  _avg: NestedProjectLevel1AvgAggregate
  _count: NestedProjectLevel1CountAggregate
  _max: NestedProjectLevel1MaxAggregate
  _min: NestedProjectLevel1MinAggregate
  _sum: NestedProjectLevel1SumAggregate
}

type AggregateNestedProjectLevel2 {
  _avg: NestedProjectLevel2AvgAggregate
  _count: NestedProjectLevel2CountAggregate
  _max: NestedProjectLevel2MaxAggregate
  _min: NestedProjectLevel2MinAggregate
  _sum: NestedProjectLevel2SumAggregate
}

type AggregateProfile {
  _avg: ProfileAvgAggregate
  _count: ProfileCountAggregate
  _max: ProfileMaxAggregate
  _min: ProfileMinAggregate
  _sum: ProfileSumAggregate
}

type AggregateProject {
  _avg: ProjectAvgAggregate
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  _sum: ProjectSumAggregate
}

type AggregatePublication {
  _avg: PublicationAvgAggregate
  _count: PublicationCountAggregate
  _max: PublicationMaxAggregate
  _min: PublicationMinAggregate
  _sum: PublicationSumAggregate
}

type AggregateReference {
  _avg: ReferenceAvgAggregate
  _count: ReferenceCountAggregate
  _max: ReferenceMaxAggregate
  _min: ReferenceMinAggregate
  _sum: ReferenceSumAggregate
}

type AggregateSkill {
  _avg: SkillAvgAggregate
  _count: SkillCountAggregate
  _max: SkillMaxAggregate
  _min: SkillMinAggregate
  _sum: SkillSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregateVolunteer {
  _avg: VolunteerAvgAggregate
  _count: VolunteerCountAggregate
  _max: VolunteerMaxAggregate
  _min: VolunteerMinAggregate
  _sum: VolunteerSumAggregate
}

type AggregateWork {
  _avg: WorkAvgAggregate
  _count: WorkCountAggregate
  _max: WorkMaxAggregate
  _min: WorkMinAggregate
  _sum: WorkSumAggregate
}

type Award {
  awarder: String!
  date: DateTime!
  id: Int!
  project: Project
  projectId: Int!
  summary: String!
  title: String!
}

type AwardAvgAggregate {
  id: Float
  projectId: Float
}

input AwardAvgOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

type AwardCountAggregate {
  _all: Int!
  awarder: Int!
  date: Int!
  id: Int!
  projectId: Int!
  summary: Int!
  title: Int!
}

input AwardCountOrderByAggregateInput {
  awarder: SortOrder
  date: SortOrder
  id: SortOrder
  projectId: SortOrder
  summary: SortOrder
  title: SortOrder
}

input AwardCreateInput {
  awarder: String!
  date: DateTime!
  project: ProjectCreateNestedOneWithoutAwardsInput
  summary: String!
  title: String!
}

input AwardCreateManyInput {
  awarder: String!
  date: DateTime!
  id: Int
  projectId: Int!
  summary: String!
  title: String!
}

input AwardCreateManyProjectInput {
  awarder: String!
  date: DateTime!
  id: Int
  summary: String!
  title: String!
}

input AwardCreateManyProjectInputEnvelope {
  data: [AwardCreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input AwardCreateNestedManyWithoutProjectInput {
  connect: [AwardWhereUniqueInput!]
  connectOrCreate: [AwardCreateOrConnectWithoutProjectInput!]
  create: [AwardCreateWithoutProjectInput!]
  createMany: AwardCreateManyProjectInputEnvelope
}

input AwardCreateOrConnectWithoutProjectInput {
  create: AwardCreateWithoutProjectInput!
  where: AwardWhereUniqueInput!
}

input AwardCreateWithoutProjectInput {
  awarder: String!
  date: DateTime!
  summary: String!
  title: String!
}

type AwardGroupBy {
  _avg: AwardAvgAggregate
  _count: AwardCountAggregate
  _max: AwardMaxAggregate
  _min: AwardMinAggregate
  _sum: AwardSumAggregate
  awarder: String!
  date: DateTime!
  id: Int!
  projectId: Int!
  summary: String!
  title: String!
}

input AwardListRelationFilter {
  every: AwardWhereInput
  none: AwardWhereInput
  some: AwardWhereInput
}

type AwardMaxAggregate {
  awarder: String
  date: DateTime
  id: Int
  projectId: Int
  summary: String
  title: String
}

input AwardMaxOrderByAggregateInput {
  awarder: SortOrder
  date: SortOrder
  id: SortOrder
  projectId: SortOrder
  summary: SortOrder
  title: SortOrder
}

type AwardMinAggregate {
  awarder: String
  date: DateTime
  id: Int
  projectId: Int
  summary: String
  title: String
}

input AwardMinOrderByAggregateInput {
  awarder: SortOrder
  date: SortOrder
  id: SortOrder
  projectId: SortOrder
  summary: SortOrder
  title: SortOrder
}

input AwardOrderByRelationAggregateInput {
  _count: SortOrder
}

input AwardOrderByWithAggregationInput {
  _avg: AwardAvgOrderByAggregateInput
  _count: AwardCountOrderByAggregateInput
  _max: AwardMaxOrderByAggregateInput
  _min: AwardMinOrderByAggregateInput
  _sum: AwardSumOrderByAggregateInput
  awarder: SortOrder
  date: SortOrder
  id: SortOrder
  projectId: SortOrder
  summary: SortOrder
  title: SortOrder
}

input AwardOrderByWithRelationInput {
  awarder: SortOrder
  date: SortOrder
  id: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
  summary: SortOrder
  title: SortOrder
}

enum AwardScalarFieldEnum {
  awarder
  date
  id
  projectId
  summary
  title
}

input AwardScalarWhereInput {
  AND: [AwardScalarWhereInput!]
  NOT: [AwardScalarWhereInput!]
  OR: [AwardScalarWhereInput!]
  awarder: StringFilter
  date: DateTimeFilter
  id: IntFilter
  projectId: IntFilter
  summary: StringFilter
  title: StringFilter
}

input AwardScalarWhereWithAggregatesInput {
  AND: [AwardScalarWhereWithAggregatesInput!]
  NOT: [AwardScalarWhereWithAggregatesInput!]
  OR: [AwardScalarWhereWithAggregatesInput!]
  awarder: StringWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  projectId: IntWithAggregatesFilter
  summary: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type AwardSumAggregate {
  id: Int
  projectId: Int
}

input AwardSumOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

input AwardUpdateInput {
  awarder: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutAwardsNestedInput
  summary: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input AwardUpdateManyMutationInput {
  awarder: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input AwardUpdateManyWithWhereWithoutProjectInput {
  data: AwardUpdateManyMutationInput!
  where: AwardScalarWhereInput!
}

input AwardUpdateManyWithoutProjectNestedInput {
  connect: [AwardWhereUniqueInput!]
  connectOrCreate: [AwardCreateOrConnectWithoutProjectInput!]
  create: [AwardCreateWithoutProjectInput!]
  createMany: AwardCreateManyProjectInputEnvelope
  delete: [AwardWhereUniqueInput!]
  deleteMany: [AwardScalarWhereInput!]
  disconnect: [AwardWhereUniqueInput!]
  set: [AwardWhereUniqueInput!]
  update: [AwardUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [AwardUpdateManyWithWhereWithoutProjectInput!]
  upsert: [AwardUpsertWithWhereUniqueWithoutProjectInput!]
}

input AwardUpdateWithWhereUniqueWithoutProjectInput {
  data: AwardUpdateWithoutProjectInput!
  where: AwardWhereUniqueInput!
}

input AwardUpdateWithoutProjectInput {
  awarder: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input AwardUpsertWithWhereUniqueWithoutProjectInput {
  create: AwardCreateWithoutProjectInput!
  update: AwardUpdateWithoutProjectInput!
  where: AwardWhereUniqueInput!
}

input AwardWhereInput {
  AND: [AwardWhereInput!]
  NOT: [AwardWhereInput!]
  OR: [AwardWhereInput!]
  awarder: StringFilter
  date: DateTimeFilter
  id: IntFilter
  project: ProjectRelationFilter
  projectId: IntFilter
  summary: StringFilter
  title: StringFilter
}

input AwardWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Education {
  area: String!
  courses: [String!]!
  endDate: DateTime!
  id: Int!
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
  user: User
  userId: Int!
}

type EducationAvgAggregate {
  id: Float
  userId: Float
}

input EducationAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type EducationCountAggregate {
  _all: Int!
  area: Int!
  courses: Int!
  endDate: Int!
  id: Int!
  institution: Int!
  score: Int!
  startDate: Int!
  studyType: Int!
  url: Int!
  userId: Int!
}

input EducationCountOrderByAggregateInput {
  area: SortOrder
  courses: SortOrder
  endDate: SortOrder
  id: SortOrder
  institution: SortOrder
  score: SortOrder
  startDate: SortOrder
  studyType: SortOrder
  url: SortOrder
  userId: SortOrder
}

input EducationCreateInput {
  area: String!
  courses: EducationCreatecoursesInput
  endDate: DateTime!
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
  user: UserCreateNestedOneWithoutEducationInput
}

input EducationCreateManyInput {
  area: String!
  courses: EducationCreatecoursesInput
  endDate: DateTime!
  id: Int
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
  userId: Int!
}

input EducationCreateManyUserInput {
  area: String!
  courses: EducationCreatecoursesInput
  endDate: DateTime!
  id: Int
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
}

input EducationCreateManyUserInputEnvelope {
  data: [EducationCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input EducationCreateNestedManyWithoutUserInput {
  connect: [EducationWhereUniqueInput!]
  connectOrCreate: [EducationCreateOrConnectWithoutUserInput!]
  create: [EducationCreateWithoutUserInput!]
  createMany: EducationCreateManyUserInputEnvelope
}

input EducationCreateOrConnectWithoutUserInput {
  create: EducationCreateWithoutUserInput!
  where: EducationWhereUniqueInput!
}

input EducationCreateWithoutUserInput {
  area: String!
  courses: EducationCreatecoursesInput
  endDate: DateTime!
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
}

input EducationCreatecoursesInput {
  set: [String!]!
}

type EducationGroupBy {
  _avg: EducationAvgAggregate
  _count: EducationCountAggregate
  _max: EducationMaxAggregate
  _min: EducationMinAggregate
  _sum: EducationSumAggregate
  area: String!
  courses: [String!]
  endDate: DateTime!
  id: Int!
  institution: String!
  score: String!
  startDate: DateTime!
  studyType: String!
  url: String!
  userId: Int!
}

input EducationListRelationFilter {
  every: EducationWhereInput
  none: EducationWhereInput
  some: EducationWhereInput
}

type EducationMaxAggregate {
  area: String
  endDate: DateTime
  id: Int
  institution: String
  score: String
  startDate: DateTime
  studyType: String
  url: String
  userId: Int
}

input EducationMaxOrderByAggregateInput {
  area: SortOrder
  endDate: SortOrder
  id: SortOrder
  institution: SortOrder
  score: SortOrder
  startDate: SortOrder
  studyType: SortOrder
  url: SortOrder
  userId: SortOrder
}

type EducationMinAggregate {
  area: String
  endDate: DateTime
  id: Int
  institution: String
  score: String
  startDate: DateTime
  studyType: String
  url: String
  userId: Int
}

input EducationMinOrderByAggregateInput {
  area: SortOrder
  endDate: SortOrder
  id: SortOrder
  institution: SortOrder
  score: SortOrder
  startDate: SortOrder
  studyType: SortOrder
  url: SortOrder
  userId: SortOrder
}

input EducationOrderByRelationAggregateInput {
  _count: SortOrder
}

input EducationOrderByWithAggregationInput {
  _avg: EducationAvgOrderByAggregateInput
  _count: EducationCountOrderByAggregateInput
  _max: EducationMaxOrderByAggregateInput
  _min: EducationMinOrderByAggregateInput
  _sum: EducationSumOrderByAggregateInput
  area: SortOrder
  courses: SortOrder
  endDate: SortOrder
  id: SortOrder
  institution: SortOrder
  score: SortOrder
  startDate: SortOrder
  studyType: SortOrder
  url: SortOrder
  userId: SortOrder
}

input EducationOrderByWithRelationInput {
  area: SortOrder
  courses: SortOrder
  endDate: SortOrder
  id: SortOrder
  institution: SortOrder
  score: SortOrder
  startDate: SortOrder
  studyType: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum EducationScalarFieldEnum {
  area
  courses
  endDate
  id
  institution
  score
  startDate
  studyType
  url
  userId
}

input EducationScalarWhereInput {
  AND: [EducationScalarWhereInput!]
  NOT: [EducationScalarWhereInput!]
  OR: [EducationScalarWhereInput!]
  area: StringFilter
  courses: StringNullableListFilter
  endDate: DateTimeFilter
  id: IntFilter
  institution: StringFilter
  score: StringFilter
  startDate: DateTimeFilter
  studyType: StringFilter
  url: StringFilter
  userId: IntFilter
}

input EducationScalarWhereWithAggregatesInput {
  AND: [EducationScalarWhereWithAggregatesInput!]
  NOT: [EducationScalarWhereWithAggregatesInput!]
  OR: [EducationScalarWhereWithAggregatesInput!]
  area: StringWithAggregatesFilter
  courses: StringNullableListFilter
  endDate: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  institution: StringWithAggregatesFilter
  score: StringWithAggregatesFilter
  startDate: DateTimeWithAggregatesFilter
  studyType: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type EducationSumAggregate {
  id: Int
  userId: Int
}

input EducationSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input EducationUpdateInput {
  area: StringFieldUpdateOperationsInput
  courses: EducationUpdatecoursesInput
  endDate: DateTimeFieldUpdateOperationsInput
  institution: StringFieldUpdateOperationsInput
  score: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  studyType: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutEducationNestedInput
}

input EducationUpdateManyMutationInput {
  area: StringFieldUpdateOperationsInput
  courses: EducationUpdatecoursesInput
  endDate: DateTimeFieldUpdateOperationsInput
  institution: StringFieldUpdateOperationsInput
  score: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  studyType: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input EducationUpdateManyWithWhereWithoutUserInput {
  data: EducationUpdateManyMutationInput!
  where: EducationScalarWhereInput!
}

input EducationUpdateManyWithoutUserNestedInput {
  connect: [EducationWhereUniqueInput!]
  connectOrCreate: [EducationCreateOrConnectWithoutUserInput!]
  create: [EducationCreateWithoutUserInput!]
  createMany: EducationCreateManyUserInputEnvelope
  delete: [EducationWhereUniqueInput!]
  deleteMany: [EducationScalarWhereInput!]
  disconnect: [EducationWhereUniqueInput!]
  set: [EducationWhereUniqueInput!]
  update: [EducationUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [EducationUpdateManyWithWhereWithoutUserInput!]
  upsert: [EducationUpsertWithWhereUniqueWithoutUserInput!]
}

input EducationUpdateWithWhereUniqueWithoutUserInput {
  data: EducationUpdateWithoutUserInput!
  where: EducationWhereUniqueInput!
}

input EducationUpdateWithoutUserInput {
  area: StringFieldUpdateOperationsInput
  courses: EducationUpdatecoursesInput
  endDate: DateTimeFieldUpdateOperationsInput
  institution: StringFieldUpdateOperationsInput
  score: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  studyType: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input EducationUpdatecoursesInput {
  push: [String!]
  set: [String!]
}

input EducationUpsertWithWhereUniqueWithoutUserInput {
  create: EducationCreateWithoutUserInput!
  update: EducationUpdateWithoutUserInput!
  where: EducationWhereUniqueInput!
}

input EducationWhereInput {
  AND: [EducationWhereInput!]
  NOT: [EducationWhereInput!]
  OR: [EducationWhereInput!]
  area: StringFilter
  courses: StringNullableListFilter
  endDate: DateTimeFilter
  id: IntFilter
  institution: StringFilter
  score: StringFilter
  startDate: DateTimeFilter
  studyType: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input EducationWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Interest {
  id: Int!
  keywords: [String!]!
  name: String!
  user: User
  userId: Int!
}

type InterestAvgAggregate {
  id: Float
  userId: Float
}

input InterestAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type InterestCountAggregate {
  _all: Int!
  id: Int!
  keywords: Int!
  name: Int!
  userId: Int!
}

input InterestCountOrderByAggregateInput {
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  userId: SortOrder
}

input InterestCreateInput {
  keywords: InterestCreatekeywordsInput
  name: String!
  user: UserCreateNestedOneWithoutInterestsInput
}

input InterestCreateManyInput {
  id: Int
  keywords: InterestCreatekeywordsInput
  name: String!
  userId: Int!
}

input InterestCreateManyUserInput {
  id: Int
  keywords: InterestCreatekeywordsInput
  name: String!
}

input InterestCreateManyUserInputEnvelope {
  data: [InterestCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input InterestCreateNestedManyWithoutUserInput {
  connect: [InterestWhereUniqueInput!]
  connectOrCreate: [InterestCreateOrConnectWithoutUserInput!]
  create: [InterestCreateWithoutUserInput!]
  createMany: InterestCreateManyUserInputEnvelope
}

input InterestCreateOrConnectWithoutUserInput {
  create: InterestCreateWithoutUserInput!
  where: InterestWhereUniqueInput!
}

input InterestCreateWithoutUserInput {
  keywords: InterestCreatekeywordsInput
  name: String!
}

input InterestCreatekeywordsInput {
  set: [String!]!
}

type InterestGroupBy {
  _avg: InterestAvgAggregate
  _count: InterestCountAggregate
  _max: InterestMaxAggregate
  _min: InterestMinAggregate
  _sum: InterestSumAggregate
  id: Int!
  keywords: [String!]
  name: String!
  userId: Int!
}

input InterestListRelationFilter {
  every: InterestWhereInput
  none: InterestWhereInput
  some: InterestWhereInput
}

type InterestMaxAggregate {
  id: Int
  name: String
  userId: Int
}

input InterestMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

type InterestMinAggregate {
  id: Int
  name: String
  userId: Int
}

input InterestMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

input InterestOrderByRelationAggregateInput {
  _count: SortOrder
}

input InterestOrderByWithAggregationInput {
  _avg: InterestAvgOrderByAggregateInput
  _count: InterestCountOrderByAggregateInput
  _max: InterestMaxOrderByAggregateInput
  _min: InterestMinOrderByAggregateInput
  _sum: InterestSumOrderByAggregateInput
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  userId: SortOrder
}

input InterestOrderByWithRelationInput {
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum InterestScalarFieldEnum {
  id
  keywords
  name
  userId
}

input InterestScalarWhereInput {
  AND: [InterestScalarWhereInput!]
  NOT: [InterestScalarWhereInput!]
  OR: [InterestScalarWhereInput!]
  id: IntFilter
  keywords: StringNullableListFilter
  name: StringFilter
  userId: IntFilter
}

input InterestScalarWhereWithAggregatesInput {
  AND: [InterestScalarWhereWithAggregatesInput!]
  NOT: [InterestScalarWhereWithAggregatesInput!]
  OR: [InterestScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  keywords: StringNullableListFilter
  name: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type InterestSumAggregate {
  id: Int
  userId: Int
}

input InterestSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input InterestUpdateInput {
  keywords: InterestUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutInterestsNestedInput
}

input InterestUpdateManyMutationInput {
  keywords: InterestUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
}

input InterestUpdateManyWithWhereWithoutUserInput {
  data: InterestUpdateManyMutationInput!
  where: InterestScalarWhereInput!
}

input InterestUpdateManyWithoutUserNestedInput {
  connect: [InterestWhereUniqueInput!]
  connectOrCreate: [InterestCreateOrConnectWithoutUserInput!]
  create: [InterestCreateWithoutUserInput!]
  createMany: InterestCreateManyUserInputEnvelope
  delete: [InterestWhereUniqueInput!]
  deleteMany: [InterestScalarWhereInput!]
  disconnect: [InterestWhereUniqueInput!]
  set: [InterestWhereUniqueInput!]
  update: [InterestUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [InterestUpdateManyWithWhereWithoutUserInput!]
  upsert: [InterestUpsertWithWhereUniqueWithoutUserInput!]
}

input InterestUpdateWithWhereUniqueWithoutUserInput {
  data: InterestUpdateWithoutUserInput!
  where: InterestWhereUniqueInput!
}

input InterestUpdateWithoutUserInput {
  keywords: InterestUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
}

input InterestUpdatekeywordsInput {
  push: [String!]
  set: [String!]
}

input InterestUpsertWithWhereUniqueWithoutUserInput {
  create: InterestCreateWithoutUserInput!
  update: InterestUpdateWithoutUserInput!
  where: InterestWhereUniqueInput!
}

input InterestWhereInput {
  AND: [InterestWhereInput!]
  NOT: [InterestWhereInput!]
  OR: [InterestWhereInput!]
  id: IntFilter
  keywords: StringNullableListFilter
  name: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input InterestWhereUniqueInput {
  id: Int
}

type Language {
  fluency: String!
  id: Int!
  name: String!
  user: User
  userId: Int!
}

type LanguageAvgAggregate {
  id: Float
  userId: Float
}

input LanguageAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type LanguageCountAggregate {
  _all: Int!
  fluency: Int!
  id: Int!
  name: Int!
  userId: Int!
}

input LanguageCountOrderByAggregateInput {
  fluency: SortOrder
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

input LanguageCreateInput {
  fluency: String!
  name: String!
  user: UserCreateNestedOneWithoutLanguagesInput
}

input LanguageCreateManyInput {
  fluency: String!
  id: Int
  name: String!
  userId: Int!
}

input LanguageCreateManyUserInput {
  fluency: String!
  id: Int
  name: String!
}

input LanguageCreateManyUserInputEnvelope {
  data: [LanguageCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input LanguageCreateNestedManyWithoutUserInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutUserInput!]
  create: [LanguageCreateWithoutUserInput!]
  createMany: LanguageCreateManyUserInputEnvelope
}

input LanguageCreateOrConnectWithoutUserInput {
  create: LanguageCreateWithoutUserInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateWithoutUserInput {
  fluency: String!
  name: String!
}

type LanguageGroupBy {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
  fluency: String!
  id: Int!
  name: String!
  userId: Int!
}

input LanguageListRelationFilter {
  every: LanguageWhereInput
  none: LanguageWhereInput
  some: LanguageWhereInput
}

type LanguageMaxAggregate {
  fluency: String
  id: Int
  name: String
  userId: Int
}

input LanguageMaxOrderByAggregateInput {
  fluency: SortOrder
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

type LanguageMinAggregate {
  fluency: String
  id: Int
  name: String
  userId: Int
}

input LanguageMinOrderByAggregateInput {
  fluency: SortOrder
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

input LanguageOrderByRelationAggregateInput {
  _count: SortOrder
}

input LanguageOrderByWithAggregationInput {
  _avg: LanguageAvgOrderByAggregateInput
  _count: LanguageCountOrderByAggregateInput
  _max: LanguageMaxOrderByAggregateInput
  _min: LanguageMinOrderByAggregateInput
  _sum: LanguageSumOrderByAggregateInput
  fluency: SortOrder
  id: SortOrder
  name: SortOrder
  userId: SortOrder
}

input LanguageOrderByWithRelationInput {
  fluency: SortOrder
  id: SortOrder
  name: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum LanguageScalarFieldEnum {
  fluency
  id
  name
  userId
}

input LanguageScalarWhereInput {
  AND: [LanguageScalarWhereInput!]
  NOT: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  fluency: StringFilter
  id: IntFilter
  name: StringFilter
  userId: IntFilter
}

input LanguageScalarWhereWithAggregatesInput {
  AND: [LanguageScalarWhereWithAggregatesInput!]
  NOT: [LanguageScalarWhereWithAggregatesInput!]
  OR: [LanguageScalarWhereWithAggregatesInput!]
  fluency: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type LanguageSumAggregate {
  id: Int
  userId: Int
}

input LanguageSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input LanguageUpdateInput {
  fluency: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutLanguagesNestedInput
}

input LanguageUpdateManyMutationInput {
  fluency: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpdateManyWithWhereWithoutUserInput {
  data: LanguageUpdateManyMutationInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateManyWithoutUserNestedInput {
  connect: [LanguageWhereUniqueInput!]
  connectOrCreate: [LanguageCreateOrConnectWithoutUserInput!]
  create: [LanguageCreateWithoutUserInput!]
  createMany: LanguageCreateManyUserInputEnvelope
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LanguageUpdateManyWithWhereWithoutUserInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutUserInput!]
}

input LanguageUpdateWithWhereUniqueWithoutUserInput {
  data: LanguageUpdateWithoutUserInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpdateWithoutUserInput {
  fluency: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpsertWithWhereUniqueWithoutUserInput {
  create: LanguageCreateWithoutUserInput!
  update: LanguageUpdateWithoutUserInput!
  where: LanguageWhereUniqueInput!
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  fluency: StringFilter
  id: IntFilter
  name: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input LanguageWhereUniqueInput {
  id: Int
}

type Location {
  address: String!
  city: String!
  countryCode: String!
  id: Int!
  postalCode: String!
  region: String!
  user: User
  userId: Int!
}

type LocationAvgAggregate {
  id: Float
  userId: Float
}

input LocationAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type LocationCountAggregate {
  _all: Int!
  address: Int!
  city: Int!
  countryCode: Int!
  id: Int!
  postalCode: Int!
  region: Int!
  userId: Int!
}

input LocationCountOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  countryCode: SortOrder
  id: SortOrder
  postalCode: SortOrder
  region: SortOrder
  userId: SortOrder
}

input LocationCreateInput {
  address: String!
  city: String!
  countryCode: String!
  postalCode: String!
  region: String!
  user: UserCreateNestedOneWithoutLocationInput
}

input LocationCreateManyInput {
  address: String!
  city: String!
  countryCode: String!
  id: Int
  postalCode: String!
  region: String!
  userId: Int!
}

input LocationCreateNestedOneWithoutUserInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutUserInput
  create: LocationCreateWithoutUserInput
}

input LocationCreateOrConnectWithoutUserInput {
  create: LocationCreateWithoutUserInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateWithoutUserInput {
  address: String!
  city: String!
  countryCode: String!
  postalCode: String!
  region: String!
}

type LocationGroupBy {
  _avg: LocationAvgAggregate
  _count: LocationCountAggregate
  _max: LocationMaxAggregate
  _min: LocationMinAggregate
  _sum: LocationSumAggregate
  address: String!
  city: String!
  countryCode: String!
  id: Int!
  postalCode: String!
  region: String!
  userId: Int!
}

type LocationMaxAggregate {
  address: String
  city: String
  countryCode: String
  id: Int
  postalCode: String
  region: String
  userId: Int
}

input LocationMaxOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  countryCode: SortOrder
  id: SortOrder
  postalCode: SortOrder
  region: SortOrder
  userId: SortOrder
}

type LocationMinAggregate {
  address: String
  city: String
  countryCode: String
  id: Int
  postalCode: String
  region: String
  userId: Int
}

input LocationMinOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  countryCode: SortOrder
  id: SortOrder
  postalCode: SortOrder
  region: SortOrder
  userId: SortOrder
}

input LocationOrderByWithAggregationInput {
  _avg: LocationAvgOrderByAggregateInput
  _count: LocationCountOrderByAggregateInput
  _max: LocationMaxOrderByAggregateInput
  _min: LocationMinOrderByAggregateInput
  _sum: LocationSumOrderByAggregateInput
  address: SortOrder
  city: SortOrder
  countryCode: SortOrder
  id: SortOrder
  postalCode: SortOrder
  region: SortOrder
  userId: SortOrder
}

input LocationOrderByWithRelationInput {
  address: SortOrder
  city: SortOrder
  countryCode: SortOrder
  id: SortOrder
  postalCode: SortOrder
  region: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input LocationRelationFilter {
  is: LocationWhereInput
  isNot: LocationWhereInput
}

enum LocationScalarFieldEnum {
  address
  city
  countryCode
  id
  postalCode
  region
  userId
}

input LocationScalarWhereWithAggregatesInput {
  AND: [LocationScalarWhereWithAggregatesInput!]
  NOT: [LocationScalarWhereWithAggregatesInput!]
  OR: [LocationScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  city: StringWithAggregatesFilter
  countryCode: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  postalCode: StringWithAggregatesFilter
  region: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type LocationSumAggregate {
  id: Int
  userId: Int
}

input LocationSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input LocationUpdateInput {
  address: StringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  countryCode: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  region: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutLocationNestedInput
}

input LocationUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  countryCode: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  region: StringFieldUpdateOperationsInput
}

input LocationUpdateOneWithoutUserNestedInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutUserInput
  create: LocationCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: LocationUpdateWithoutUserInput
  upsert: LocationUpsertWithoutUserInput
}

input LocationUpdateWithoutUserInput {
  address: StringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  countryCode: StringFieldUpdateOperationsInput
  postalCode: StringFieldUpdateOperationsInput
  region: StringFieldUpdateOperationsInput
}

input LocationUpsertWithoutUserInput {
  create: LocationCreateWithoutUserInput!
  update: LocationUpdateWithoutUserInput!
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  address: StringFilter
  city: StringFilter
  countryCode: StringFilter
  id: IntFilter
  postalCode: StringFilter
  region: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input LocationWhereUniqueInput {
  id: Int
  userId: Int
}

type Mutation {
  createManyAward(data: [AwardCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEducation(data: [EducationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInterest(data: [InterestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLanguage(data: [LanguageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLocation(data: [LocationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNestedProjectLevel1(data: [NestedProjectLevel1CreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNestedProjectLevel2(data: [NestedProjectLevel2CreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProfile(data: [ProfileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProject(data: [ProjectCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPublication(data: [PublicationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyReference(data: [ReferenceCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySkill(data: [SkillCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyVolunteer(data: [VolunteerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyWork(data: [WorkCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAward(data: AwardCreateInput!): Award!
  createOneEducation(data: EducationCreateInput!): Education!
  createOneInterest(data: InterestCreateInput!): Interest!
  createOneLanguage(data: LanguageCreateInput!): Language!
  createOneLocation(data: LocationCreateInput!): Location!
  createOneNestedProjectLevel1(data: NestedProjectLevel1CreateInput!): NestedProjectLevel1!
  createOneNestedProjectLevel2(data: NestedProjectLevel2CreateInput!): NestedProjectLevel2!
  createOneProfile(data: ProfileCreateInput!): Profile!
  createOneProject(data: ProjectCreateInput!): Project!
  createOnePublication(data: PublicationCreateInput!): Publication!
  createOneReference(data: ReferenceCreateInput!): Reference!
  createOneSkill(data: SkillCreateInput!): Skill!
  createOneUser(data: UserCreateInput!): User!
  createOneVolunteer(data: VolunteerCreateInput!): Volunteer!
  createOneWork(data: WorkCreateInput!): Work!
  deleteManyAward(where: AwardWhereInput): AffectedRowsOutput!
  deleteManyEducation(where: EducationWhereInput): AffectedRowsOutput!
  deleteManyInterest(where: InterestWhereInput): AffectedRowsOutput!
  deleteManyLanguage(where: LanguageWhereInput): AffectedRowsOutput!
  deleteManyLocation(where: LocationWhereInput): AffectedRowsOutput!
  deleteManyNestedProjectLevel1(where: NestedProjectLevel1WhereInput): AffectedRowsOutput!
  deleteManyNestedProjectLevel2(where: NestedProjectLevel2WhereInput): AffectedRowsOutput!
  deleteManyProfile(where: ProfileWhereInput): AffectedRowsOutput!
  deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
  deleteManyPublication(where: PublicationWhereInput): AffectedRowsOutput!
  deleteManyReference(where: ReferenceWhereInput): AffectedRowsOutput!
  deleteManySkill(where: SkillWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyVolunteer(where: VolunteerWhereInput): AffectedRowsOutput!
  deleteManyWork(where: WorkWhereInput): AffectedRowsOutput!
  deleteOneAward(where: AwardWhereUniqueInput!): Award
  deleteOneEducation(where: EducationWhereUniqueInput!): Education
  deleteOneInterest(where: InterestWhereUniqueInput!): Interest
  deleteOneLanguage(where: LanguageWhereUniqueInput!): Language
  deleteOneLocation(where: LocationWhereUniqueInput!): Location
  deleteOneNestedProjectLevel1(where: NestedProjectLevel1WhereUniqueInput!): NestedProjectLevel1
  deleteOneNestedProjectLevel2(where: NestedProjectLevel2WhereUniqueInput!): NestedProjectLevel2
  deleteOneProfile(where: ProfileWhereUniqueInput!): Profile
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOnePublication(where: PublicationWhereUniqueInput!): Publication
  deleteOneReference(where: ReferenceWhereUniqueInput!): Reference
  deleteOneSkill(where: SkillWhereUniqueInput!): Skill
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneVolunteer(where: VolunteerWhereUniqueInput!): Volunteer
  deleteOneWork(where: WorkWhereUniqueInput!): Work
  updateManyAward(data: AwardUpdateManyMutationInput!, where: AwardWhereInput): AffectedRowsOutput!
  updateManyEducation(data: EducationUpdateManyMutationInput!, where: EducationWhereInput): AffectedRowsOutput!
  updateManyInterest(data: InterestUpdateManyMutationInput!, where: InterestWhereInput): AffectedRowsOutput!
  updateManyLanguage(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): AffectedRowsOutput!
  updateManyLocation(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): AffectedRowsOutput!
  updateManyNestedProjectLevel1(data: NestedProjectLevel1UpdateManyMutationInput!, where: NestedProjectLevel1WhereInput): AffectedRowsOutput!
  updateManyNestedProjectLevel2(data: NestedProjectLevel2UpdateManyMutationInput!, where: NestedProjectLevel2WhereInput): AffectedRowsOutput!
  updateManyProfile(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): AffectedRowsOutput!
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): AffectedRowsOutput!
  updateManyPublication(data: PublicationUpdateManyMutationInput!, where: PublicationWhereInput): AffectedRowsOutput!
  updateManyReference(data: ReferenceUpdateManyMutationInput!, where: ReferenceWhereInput): AffectedRowsOutput!
  updateManySkill(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyVolunteer(data: VolunteerUpdateManyMutationInput!, where: VolunteerWhereInput): AffectedRowsOutput!
  updateManyWork(data: WorkUpdateManyMutationInput!, where: WorkWhereInput): AffectedRowsOutput!
  updateOneAward(data: AwardUpdateInput!, where: AwardWhereUniqueInput!): Award
  updateOneEducation(data: EducationUpdateInput!, where: EducationWhereUniqueInput!): Education
  updateOneInterest(data: InterestUpdateInput!, where: InterestWhereUniqueInput!): Interest
  updateOneLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateOneLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateOneNestedProjectLevel1(data: NestedProjectLevel1UpdateInput!, where: NestedProjectLevel1WhereUniqueInput!): NestedProjectLevel1
  updateOneNestedProjectLevel2(data: NestedProjectLevel2UpdateInput!, where: NestedProjectLevel2WhereUniqueInput!): NestedProjectLevel2
  updateOneProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOnePublication(data: PublicationUpdateInput!, where: PublicationWhereUniqueInput!): Publication
  updateOneReference(data: ReferenceUpdateInput!, where: ReferenceWhereUniqueInput!): Reference
  updateOneSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneVolunteer(data: VolunteerUpdateInput!, where: VolunteerWhereUniqueInput!): Volunteer
  updateOneWork(data: WorkUpdateInput!, where: WorkWhereUniqueInput!): Work
  upsertOneAward(create: AwardCreateInput!, update: AwardUpdateInput!, where: AwardWhereUniqueInput!): Award!
  upsertOneEducation(create: EducationCreateInput!, update: EducationUpdateInput!, where: EducationWhereUniqueInput!): Education!
  upsertOneInterest(create: InterestCreateInput!, update: InterestUpdateInput!, where: InterestWhereUniqueInput!): Interest!
  upsertOneLanguage(create: LanguageCreateInput!, update: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language!
  upsertOneLocation(create: LocationCreateInput!, update: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location!
  upsertOneNestedProjectLevel1(create: NestedProjectLevel1CreateInput!, update: NestedProjectLevel1UpdateInput!, where: NestedProjectLevel1WhereUniqueInput!): NestedProjectLevel1!
  upsertOneNestedProjectLevel2(create: NestedProjectLevel2CreateInput!, update: NestedProjectLevel2UpdateInput!, where: NestedProjectLevel2WhereUniqueInput!): NestedProjectLevel2!
  upsertOneProfile(create: ProfileCreateInput!, update: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile!
  upsertOneProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertOnePublication(create: PublicationCreateInput!, update: PublicationUpdateInput!, where: PublicationWhereUniqueInput!): Publication!
  upsertOneReference(create: ReferenceCreateInput!, update: ReferenceUpdateInput!, where: ReferenceWhereUniqueInput!): Reference!
  upsertOneSkill(create: SkillCreateInput!, update: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneVolunteer(create: VolunteerCreateInput!, update: VolunteerUpdateInput!, where: VolunteerWhereUniqueInput!): Volunteer!
  upsertOneWork(create: WorkCreateInput!, update: WorkUpdateInput!, where: WorkWhereUniqueInput!): Work!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type NestedProjectLevel1 {
  _count: NestedProjectLevel1Count
  id: Int!
  level2(cursor: NestedProjectLevel2WhereUniqueInput, distinct: [NestedProjectLevel2ScalarFieldEnum!], orderBy: [NestedProjectLevel2OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel2WhereInput): [NestedProjectLevel2!]!
  name: String!
  project: Project
  projectId: Int!
}

type NestedProjectLevel1AvgAggregate {
  id: Float
  projectId: Float
}

input NestedProjectLevel1AvgOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

type NestedProjectLevel1Count {
  level2: Int!
}

type NestedProjectLevel1CountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  projectId: Int!
}

input NestedProjectLevel1CountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel1CreateInput {
  level2: NestedProjectLevel2CreateNestedManyWithoutProjectInput
  name: String!
  project: ProjectCreateNestedOneWithoutNestedLevel1Input
}

input NestedProjectLevel1CreateManyInput {
  id: Int
  name: String!
  projectId: Int!
}

input NestedProjectLevel1CreateManyProjectInput {
  id: Int
  name: String!
}

input NestedProjectLevel1CreateManyProjectInputEnvelope {
  data: [NestedProjectLevel1CreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input NestedProjectLevel1CreateNestedManyWithoutProjectInput {
  connect: [NestedProjectLevel1WhereUniqueInput!]
  connectOrCreate: [NestedProjectLevel1CreateOrConnectWithoutProjectInput!]
  create: [NestedProjectLevel1CreateWithoutProjectInput!]
  createMany: NestedProjectLevel1CreateManyProjectInputEnvelope
}

input NestedProjectLevel1CreateNestedOneWithoutLevel2Input {
  connect: NestedProjectLevel1WhereUniqueInput
  connectOrCreate: NestedProjectLevel1CreateOrConnectWithoutLevel2Input
  create: NestedProjectLevel1CreateWithoutLevel2Input
}

input NestedProjectLevel1CreateOrConnectWithoutLevel2Input {
  create: NestedProjectLevel1CreateWithoutLevel2Input!
  where: NestedProjectLevel1WhereUniqueInput!
}

input NestedProjectLevel1CreateOrConnectWithoutProjectInput {
  create: NestedProjectLevel1CreateWithoutProjectInput!
  where: NestedProjectLevel1WhereUniqueInput!
}

input NestedProjectLevel1CreateWithoutLevel2Input {
  name: String!
  project: ProjectCreateNestedOneWithoutNestedLevel1Input
}

input NestedProjectLevel1CreateWithoutProjectInput {
  level2: NestedProjectLevel2CreateNestedManyWithoutProjectInput
  name: String!
}

type NestedProjectLevel1GroupBy {
  _avg: NestedProjectLevel1AvgAggregate
  _count: NestedProjectLevel1CountAggregate
  _max: NestedProjectLevel1MaxAggregate
  _min: NestedProjectLevel1MinAggregate
  _sum: NestedProjectLevel1SumAggregate
  id: Int!
  name: String!
  projectId: Int!
}

input NestedProjectLevel1ListRelationFilter {
  every: NestedProjectLevel1WhereInput
  none: NestedProjectLevel1WhereInput
  some: NestedProjectLevel1WhereInput
}

type NestedProjectLevel1MaxAggregate {
  id: Int
  name: String
  projectId: Int
}

input NestedProjectLevel1MaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

type NestedProjectLevel1MinAggregate {
  id: Int
  name: String
  projectId: Int
}

input NestedProjectLevel1MinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel1OrderByRelationAggregateInput {
  _count: SortOrder
}

input NestedProjectLevel1OrderByWithAggregationInput {
  _avg: NestedProjectLevel1AvgOrderByAggregateInput
  _count: NestedProjectLevel1CountOrderByAggregateInput
  _max: NestedProjectLevel1MaxOrderByAggregateInput
  _min: NestedProjectLevel1MinOrderByAggregateInput
  _sum: NestedProjectLevel1SumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel1OrderByWithRelationInput {
  id: SortOrder
  level2: NestedProjectLevel2OrderByRelationAggregateInput
  name: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
}

input NestedProjectLevel1RelationFilter {
  is: NestedProjectLevel1WhereInput
  isNot: NestedProjectLevel1WhereInput
}

enum NestedProjectLevel1ScalarFieldEnum {
  id
  name
  projectId
}

input NestedProjectLevel1ScalarWhereInput {
  AND: [NestedProjectLevel1ScalarWhereInput!]
  NOT: [NestedProjectLevel1ScalarWhereInput!]
  OR: [NestedProjectLevel1ScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  projectId: IntFilter
}

input NestedProjectLevel1ScalarWhereWithAggregatesInput {
  AND: [NestedProjectLevel1ScalarWhereWithAggregatesInput!]
  NOT: [NestedProjectLevel1ScalarWhereWithAggregatesInput!]
  OR: [NestedProjectLevel1ScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  projectId: IntWithAggregatesFilter
}

type NestedProjectLevel1SumAggregate {
  id: Int
  projectId: Int
}

input NestedProjectLevel1SumOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel1UpdateInput {
  level2: NestedProjectLevel2UpdateManyWithoutProjectNestedInput
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutNestedLevel1NestedInput
}

input NestedProjectLevel1UpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input NestedProjectLevel1UpdateManyWithWhereWithoutProjectInput {
  data: NestedProjectLevel1UpdateManyMutationInput!
  where: NestedProjectLevel1ScalarWhereInput!
}

input NestedProjectLevel1UpdateManyWithoutProjectNestedInput {
  connect: [NestedProjectLevel1WhereUniqueInput!]
  connectOrCreate: [NestedProjectLevel1CreateOrConnectWithoutProjectInput!]
  create: [NestedProjectLevel1CreateWithoutProjectInput!]
  createMany: NestedProjectLevel1CreateManyProjectInputEnvelope
  delete: [NestedProjectLevel1WhereUniqueInput!]
  deleteMany: [NestedProjectLevel1ScalarWhereInput!]
  disconnect: [NestedProjectLevel1WhereUniqueInput!]
  set: [NestedProjectLevel1WhereUniqueInput!]
  update: [NestedProjectLevel1UpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [NestedProjectLevel1UpdateManyWithWhereWithoutProjectInput!]
  upsert: [NestedProjectLevel1UpsertWithWhereUniqueWithoutProjectInput!]
}

input NestedProjectLevel1UpdateOneWithoutLevel2NestedInput {
  connect: NestedProjectLevel1WhereUniqueInput
  connectOrCreate: NestedProjectLevel1CreateOrConnectWithoutLevel2Input
  create: NestedProjectLevel1CreateWithoutLevel2Input
  delete: Boolean
  disconnect: Boolean
  update: NestedProjectLevel1UpdateWithoutLevel2Input
  upsert: NestedProjectLevel1UpsertWithoutLevel2Input
}

input NestedProjectLevel1UpdateWithWhereUniqueWithoutProjectInput {
  data: NestedProjectLevel1UpdateWithoutProjectInput!
  where: NestedProjectLevel1WhereUniqueInput!
}

input NestedProjectLevel1UpdateWithoutLevel2Input {
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutNestedLevel1NestedInput
}

input NestedProjectLevel1UpdateWithoutProjectInput {
  level2: NestedProjectLevel2UpdateManyWithoutProjectNestedInput
  name: StringFieldUpdateOperationsInput
}

input NestedProjectLevel1UpsertWithWhereUniqueWithoutProjectInput {
  create: NestedProjectLevel1CreateWithoutProjectInput!
  update: NestedProjectLevel1UpdateWithoutProjectInput!
  where: NestedProjectLevel1WhereUniqueInput!
}

input NestedProjectLevel1UpsertWithoutLevel2Input {
  create: NestedProjectLevel1CreateWithoutLevel2Input!
  update: NestedProjectLevel1UpdateWithoutLevel2Input!
}

input NestedProjectLevel1WhereInput {
  AND: [NestedProjectLevel1WhereInput!]
  NOT: [NestedProjectLevel1WhereInput!]
  OR: [NestedProjectLevel1WhereInput!]
  id: IntFilter
  level2: NestedProjectLevel2ListRelationFilter
  name: StringFilter
  project: ProjectRelationFilter
  projectId: IntFilter
}

input NestedProjectLevel1WhereUniqueInput {
  id: Int
}

type NestedProjectLevel2 {
  id: Int!
  name: String!
  project: NestedProjectLevel1
  projectId: Int!
}

type NestedProjectLevel2AvgAggregate {
  id: Float
  projectId: Float
}

input NestedProjectLevel2AvgOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

type NestedProjectLevel2CountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  projectId: Int!
}

input NestedProjectLevel2CountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel2CreateInput {
  name: String!
  project: NestedProjectLevel1CreateNestedOneWithoutLevel2Input
}

input NestedProjectLevel2CreateManyInput {
  id: Int
  name: String!
  projectId: Int!
}

input NestedProjectLevel2CreateManyProjectInput {
  id: Int
  name: String!
}

input NestedProjectLevel2CreateManyProjectInputEnvelope {
  data: [NestedProjectLevel2CreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input NestedProjectLevel2CreateNestedManyWithoutProjectInput {
  connect: [NestedProjectLevel2WhereUniqueInput!]
  connectOrCreate: [NestedProjectLevel2CreateOrConnectWithoutProjectInput!]
  create: [NestedProjectLevel2CreateWithoutProjectInput!]
  createMany: NestedProjectLevel2CreateManyProjectInputEnvelope
}

input NestedProjectLevel2CreateOrConnectWithoutProjectInput {
  create: NestedProjectLevel2CreateWithoutProjectInput!
  where: NestedProjectLevel2WhereUniqueInput!
}

input NestedProjectLevel2CreateWithoutProjectInput {
  name: String!
}

type NestedProjectLevel2GroupBy {
  _avg: NestedProjectLevel2AvgAggregate
  _count: NestedProjectLevel2CountAggregate
  _max: NestedProjectLevel2MaxAggregate
  _min: NestedProjectLevel2MinAggregate
  _sum: NestedProjectLevel2SumAggregate
  id: Int!
  name: String!
  projectId: Int!
}

input NestedProjectLevel2ListRelationFilter {
  every: NestedProjectLevel2WhereInput
  none: NestedProjectLevel2WhereInput
  some: NestedProjectLevel2WhereInput
}

type NestedProjectLevel2MaxAggregate {
  id: Int
  name: String
  projectId: Int
}

input NestedProjectLevel2MaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

type NestedProjectLevel2MinAggregate {
  id: Int
  name: String
  projectId: Int
}

input NestedProjectLevel2MinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel2OrderByRelationAggregateInput {
  _count: SortOrder
}

input NestedProjectLevel2OrderByWithAggregationInput {
  _avg: NestedProjectLevel2AvgOrderByAggregateInput
  _count: NestedProjectLevel2CountOrderByAggregateInput
  _max: NestedProjectLevel2MaxOrderByAggregateInput
  _min: NestedProjectLevel2MinOrderByAggregateInput
  _sum: NestedProjectLevel2SumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel2OrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  project: NestedProjectLevel1OrderByWithRelationInput
  projectId: SortOrder
}

enum NestedProjectLevel2ScalarFieldEnum {
  id
  name
  projectId
}

input NestedProjectLevel2ScalarWhereInput {
  AND: [NestedProjectLevel2ScalarWhereInput!]
  NOT: [NestedProjectLevel2ScalarWhereInput!]
  OR: [NestedProjectLevel2ScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  projectId: IntFilter
}

input NestedProjectLevel2ScalarWhereWithAggregatesInput {
  AND: [NestedProjectLevel2ScalarWhereWithAggregatesInput!]
  NOT: [NestedProjectLevel2ScalarWhereWithAggregatesInput!]
  OR: [NestedProjectLevel2ScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  projectId: IntWithAggregatesFilter
}

type NestedProjectLevel2SumAggregate {
  id: Int
  projectId: Int
}

input NestedProjectLevel2SumOrderByAggregateInput {
  id: SortOrder
  projectId: SortOrder
}

input NestedProjectLevel2UpdateInput {
  name: StringFieldUpdateOperationsInput
  project: NestedProjectLevel1UpdateOneWithoutLevel2NestedInput
}

input NestedProjectLevel2UpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input NestedProjectLevel2UpdateManyWithWhereWithoutProjectInput {
  data: NestedProjectLevel2UpdateManyMutationInput!
  where: NestedProjectLevel2ScalarWhereInput!
}

input NestedProjectLevel2UpdateManyWithoutProjectNestedInput {
  connect: [NestedProjectLevel2WhereUniqueInput!]
  connectOrCreate: [NestedProjectLevel2CreateOrConnectWithoutProjectInput!]
  create: [NestedProjectLevel2CreateWithoutProjectInput!]
  createMany: NestedProjectLevel2CreateManyProjectInputEnvelope
  delete: [NestedProjectLevel2WhereUniqueInput!]
  deleteMany: [NestedProjectLevel2ScalarWhereInput!]
  disconnect: [NestedProjectLevel2WhereUniqueInput!]
  set: [NestedProjectLevel2WhereUniqueInput!]
  update: [NestedProjectLevel2UpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [NestedProjectLevel2UpdateManyWithWhereWithoutProjectInput!]
  upsert: [NestedProjectLevel2UpsertWithWhereUniqueWithoutProjectInput!]
}

input NestedProjectLevel2UpdateWithWhereUniqueWithoutProjectInput {
  data: NestedProjectLevel2UpdateWithoutProjectInput!
  where: NestedProjectLevel2WhereUniqueInput!
}

input NestedProjectLevel2UpdateWithoutProjectInput {
  name: StringFieldUpdateOperationsInput
}

input NestedProjectLevel2UpsertWithWhereUniqueWithoutProjectInput {
  create: NestedProjectLevel2CreateWithoutProjectInput!
  update: NestedProjectLevel2UpdateWithoutProjectInput!
  where: NestedProjectLevel2WhereUniqueInput!
}

input NestedProjectLevel2WhereInput {
  AND: [NestedProjectLevel2WhereInput!]
  NOT: [NestedProjectLevel2WhereInput!]
  OR: [NestedProjectLevel2WhereInput!]
  id: IntFilter
  name: StringFilter
  project: NestedProjectLevel1RelationFilter
  projectId: IntFilter
}

input NestedProjectLevel2WhereUniqueInput {
  id: Int
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Profile {
  id: Int!
  network: String!
  url: String!
  user: User
  userId: Int!
  username: String!
}

type ProfileAvgAggregate {
  id: Float
  userId: Float
}

input ProfileAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type ProfileCountAggregate {
  _all: Int!
  id: Int!
  network: Int!
  url: Int!
  userId: Int!
  username: Int!
}

input ProfileCountOrderByAggregateInput {
  id: SortOrder
  network: SortOrder
  url: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ProfileCreateInput {
  network: String!
  url: String!
  user: UserCreateNestedOneWithoutProfilesInput
  username: String!
}

input ProfileCreateManyInput {
  id: Int
  network: String!
  url: String!
  userId: Int!
  username: String!
}

input ProfileCreateManyUserInput {
  id: Int
  network: String!
  url: String!
  username: String!
}

input ProfileCreateManyUserInputEnvelope {
  data: [ProfileCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ProfileCreateNestedManyWithoutUserInput {
  connect: [ProfileWhereUniqueInput!]
  connectOrCreate: [ProfileCreateOrConnectWithoutUserInput!]
  create: [ProfileCreateWithoutUserInput!]
  createMany: ProfileCreateManyUserInputEnvelope
}

input ProfileCreateOrConnectWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  where: ProfileWhereUniqueInput!
}

input ProfileCreateWithoutUserInput {
  network: String!
  url: String!
  username: String!
}

type ProfileGroupBy {
  _avg: ProfileAvgAggregate
  _count: ProfileCountAggregate
  _max: ProfileMaxAggregate
  _min: ProfileMinAggregate
  _sum: ProfileSumAggregate
  id: Int!
  network: String!
  url: String!
  userId: Int!
  username: String!
}

input ProfileListRelationFilter {
  every: ProfileWhereInput
  none: ProfileWhereInput
  some: ProfileWhereInput
}

type ProfileMaxAggregate {
  id: Int
  network: String
  url: String
  userId: Int
  username: String
}

input ProfileMaxOrderByAggregateInput {
  id: SortOrder
  network: SortOrder
  url: SortOrder
  userId: SortOrder
  username: SortOrder
}

type ProfileMinAggregate {
  id: Int
  network: String
  url: String
  userId: Int
  username: String
}

input ProfileMinOrderByAggregateInput {
  id: SortOrder
  network: SortOrder
  url: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ProfileOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProfileOrderByWithAggregationInput {
  _avg: ProfileAvgOrderByAggregateInput
  _count: ProfileCountOrderByAggregateInput
  _max: ProfileMaxOrderByAggregateInput
  _min: ProfileMinOrderByAggregateInput
  _sum: ProfileSumOrderByAggregateInput
  id: SortOrder
  network: SortOrder
  url: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ProfileOrderByWithRelationInput {
  id: SortOrder
  network: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  username: SortOrder
}

enum ProfileScalarFieldEnum {
  id
  network
  url
  userId
  username
}

input ProfileScalarWhereInput {
  AND: [ProfileScalarWhereInput!]
  NOT: [ProfileScalarWhereInput!]
  OR: [ProfileScalarWhereInput!]
  id: IntFilter
  network: StringFilter
  url: StringFilter
  userId: IntFilter
  username: StringFilter
}

input ProfileScalarWhereWithAggregatesInput {
  AND: [ProfileScalarWhereWithAggregatesInput!]
  NOT: [ProfileScalarWhereWithAggregatesInput!]
  OR: [ProfileScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  network: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type ProfileSumAggregate {
  id: Int
  userId: Int
}

input ProfileSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input ProfileUpdateInput {
  network: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProfilesNestedInput
  username: StringFieldUpdateOperationsInput
}

input ProfileUpdateManyMutationInput {
  network: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input ProfileUpdateManyWithWhereWithoutUserInput {
  data: ProfileUpdateManyMutationInput!
  where: ProfileScalarWhereInput!
}

input ProfileUpdateManyWithoutUserNestedInput {
  connect: [ProfileWhereUniqueInput!]
  connectOrCreate: [ProfileCreateOrConnectWithoutUserInput!]
  create: [ProfileCreateWithoutUserInput!]
  createMany: ProfileCreateManyUserInputEnvelope
  delete: [ProfileWhereUniqueInput!]
  deleteMany: [ProfileScalarWhereInput!]
  disconnect: [ProfileWhereUniqueInput!]
  set: [ProfileWhereUniqueInput!]
  update: [ProfileUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProfileUpdateManyWithWhereWithoutUserInput!]
  upsert: [ProfileUpsertWithWhereUniqueWithoutUserInput!]
}

input ProfileUpdateWithWhereUniqueWithoutUserInput {
  data: ProfileUpdateWithoutUserInput!
  where: ProfileWhereUniqueInput!
}

input ProfileUpdateWithoutUserInput {
  network: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input ProfileUpsertWithWhereUniqueWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserInput!
  where: ProfileWhereUniqueInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  id: IntFilter
  network: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
  username: StringFilter
}

input ProfileWhereUniqueInput {
  id: Int
}

type Project {
  _count: ProjectCount
  awards(cursor: AwardWhereUniqueInput, distinct: [AwardScalarFieldEnum!], orderBy: [AwardOrderByWithRelationInput!], skip: Int, take: Int, where: AwardWhereInput): [Award!]!
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: [String!]!
  id: Int!
  keywords: [String!]!
  name: String!
  nestedLevel1(cursor: NestedProjectLevel1WhereUniqueInput, distinct: [NestedProjectLevel1ScalarFieldEnum!], orderBy: [NestedProjectLevel1OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel1WhereInput): [NestedProjectLevel1!]!
  roles: [String!]!
  startDate: DateTime!
  type: String!
  url: String!
  user: User
  userId: Int!
}

type ProjectAvgAggregate {
  id: Float
  userId: Float
}

input ProjectAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type ProjectCount {
  awards: Int!
  nestedLevel1: Int!
}

type ProjectCountAggregate {
  _all: Int!
  description: Int!
  endDate: Int!
  entity: Int!
  highlights: Int!
  id: Int!
  keywords: Int!
  name: Int!
  roles: Int!
  startDate: Int!
  type: Int!
  url: Int!
  userId: Int!
}

input ProjectCountOrderByAggregateInput {
  description: SortOrder
  endDate: SortOrder
  entity: SortOrder
  highlights: SortOrder
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  roles: SortOrder
  startDate: SortOrder
  type: SortOrder
  url: SortOrder
  userId: SortOrder
}

input ProjectCreateInput {
  awards: AwardCreateNestedManyWithoutProjectInput
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  keywords: ProjectCreatekeywordsInput
  name: String!
  nestedLevel1: NestedProjectLevel1CreateNestedManyWithoutProjectInput
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
  user: UserCreateNestedOneWithoutProjectsInput
}

input ProjectCreateManyInput {
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  id: Int
  keywords: ProjectCreatekeywordsInput
  name: String!
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
  userId: Int!
}

input ProjectCreateManyUserInput {
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  id: Int
  keywords: ProjectCreatekeywordsInput
  name: String!
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
}

input ProjectCreateManyUserInputEnvelope {
  data: [ProjectCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ProjectCreateNestedManyWithoutUserInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutUserInput!]
  create: [ProjectCreateWithoutUserInput!]
  createMany: ProjectCreateManyUserInputEnvelope
}

input ProjectCreateNestedOneWithoutAwardsInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutAwardsInput
  create: ProjectCreateWithoutAwardsInput
}

input ProjectCreateNestedOneWithoutNestedLevel1Input {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutNestedLevel1Input
  create: ProjectCreateWithoutNestedLevel1Input
}

input ProjectCreateOrConnectWithoutAwardsInput {
  create: ProjectCreateWithoutAwardsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutNestedLevel1Input {
  create: ProjectCreateWithoutNestedLevel1Input!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutUserInput {
  create: ProjectCreateWithoutUserInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutAwardsInput {
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  keywords: ProjectCreatekeywordsInput
  name: String!
  nestedLevel1: NestedProjectLevel1CreateNestedManyWithoutProjectInput
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
  user: UserCreateNestedOneWithoutProjectsInput
}

input ProjectCreateWithoutNestedLevel1Input {
  awards: AwardCreateNestedManyWithoutProjectInput
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  keywords: ProjectCreatekeywordsInput
  name: String!
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
  user: UserCreateNestedOneWithoutProjectsInput
}

input ProjectCreateWithoutUserInput {
  awards: AwardCreateNestedManyWithoutProjectInput
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: ProjectCreatehighlightsInput
  keywords: ProjectCreatekeywordsInput
  name: String!
  nestedLevel1: NestedProjectLevel1CreateNestedManyWithoutProjectInput
  roles: ProjectCreaterolesInput
  startDate: DateTime!
  type: String!
  url: String!
}

input ProjectCreatehighlightsInput {
  set: [String!]!
}

input ProjectCreatekeywordsInput {
  set: [String!]!
}

input ProjectCreaterolesInput {
  set: [String!]!
}

type ProjectGroupBy {
  _avg: ProjectAvgAggregate
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  _sum: ProjectSumAggregate
  description: String!
  endDate: DateTime!
  entity: String!
  highlights: [String!]
  id: Int!
  keywords: [String!]
  name: String!
  roles: [String!]
  startDate: DateTime!
  type: String!
  url: String!
  userId: Int!
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

type ProjectMaxAggregate {
  description: String
  endDate: DateTime
  entity: String
  id: Int
  name: String
  startDate: DateTime
  type: String
  url: String
  userId: Int
}

input ProjectMaxOrderByAggregateInput {
  description: SortOrder
  endDate: SortOrder
  entity: SortOrder
  id: SortOrder
  name: SortOrder
  startDate: SortOrder
  type: SortOrder
  url: SortOrder
  userId: SortOrder
}

type ProjectMinAggregate {
  description: String
  endDate: DateTime
  entity: String
  id: Int
  name: String
  startDate: DateTime
  type: String
  url: String
  userId: Int
}

input ProjectMinOrderByAggregateInput {
  description: SortOrder
  endDate: SortOrder
  entity: SortOrder
  id: SortOrder
  name: SortOrder
  startDate: SortOrder
  type: SortOrder
  url: SortOrder
  userId: SortOrder
}

input ProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProjectOrderByWithAggregationInput {
  _avg: ProjectAvgOrderByAggregateInput
  _count: ProjectCountOrderByAggregateInput
  _max: ProjectMaxOrderByAggregateInput
  _min: ProjectMinOrderByAggregateInput
  _sum: ProjectSumOrderByAggregateInput
  description: SortOrder
  endDate: SortOrder
  entity: SortOrder
  highlights: SortOrder
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  roles: SortOrder
  startDate: SortOrder
  type: SortOrder
  url: SortOrder
  userId: SortOrder
}

input ProjectOrderByWithRelationInput {
  awards: AwardOrderByRelationAggregateInput
  description: SortOrder
  endDate: SortOrder
  entity: SortOrder
  highlights: SortOrder
  id: SortOrder
  keywords: SortOrder
  name: SortOrder
  nestedLevel1: NestedProjectLevel1OrderByRelationAggregateInput
  roles: SortOrder
  startDate: SortOrder
  type: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input ProjectRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

enum ProjectScalarFieldEnum {
  description
  endDate
  entity
  highlights
  id
  keywords
  name
  roles
  startDate
  type
  url
  userId
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  description: StringFilter
  endDate: DateTimeFilter
  entity: StringFilter
  highlights: StringNullableListFilter
  id: IntFilter
  keywords: StringNullableListFilter
  name: StringFilter
  roles: StringNullableListFilter
  startDate: DateTimeFilter
  type: StringFilter
  url: StringFilter
  userId: IntFilter
}

input ProjectScalarWhereWithAggregatesInput {
  AND: [ProjectScalarWhereWithAggregatesInput!]
  NOT: [ProjectScalarWhereWithAggregatesInput!]
  OR: [ProjectScalarWhereWithAggregatesInput!]
  description: StringWithAggregatesFilter
  endDate: DateTimeWithAggregatesFilter
  entity: StringWithAggregatesFilter
  highlights: StringNullableListFilter
  id: IntWithAggregatesFilter
  keywords: StringNullableListFilter
  name: StringWithAggregatesFilter
  roles: StringNullableListFilter
  startDate: DateTimeWithAggregatesFilter
  type: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type ProjectSumAggregate {
  id: Int
  userId: Int
}

input ProjectSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input ProjectUpdateInput {
  awards: AwardUpdateManyWithoutProjectNestedInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  entity: StringFieldUpdateOperationsInput
  highlights: ProjectUpdatehighlightsInput
  keywords: ProjectUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  nestedLevel1: NestedProjectLevel1UpdateManyWithoutProjectNestedInput
  roles: ProjectUpdaterolesInput
  startDate: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProjectsNestedInput
}

input ProjectUpdateManyMutationInput {
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  entity: StringFieldUpdateOperationsInput
  highlights: ProjectUpdatehighlightsInput
  keywords: ProjectUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  roles: ProjectUpdaterolesInput
  startDate: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ProjectUpdateManyWithWhereWithoutUserInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithoutUserNestedInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutUserInput!]
  create: [ProjectCreateWithoutUserInput!]
  createMany: ProjectCreateManyUserInputEnvelope
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutUserInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUserInput!]
}

input ProjectUpdateOneWithoutAwardsNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutAwardsInput
  create: ProjectCreateWithoutAwardsInput
  delete: Boolean
  disconnect: Boolean
  update: ProjectUpdateWithoutAwardsInput
  upsert: ProjectUpsertWithoutAwardsInput
}

input ProjectUpdateOneWithoutNestedLevel1NestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutNestedLevel1Input
  create: ProjectCreateWithoutNestedLevel1Input
  delete: Boolean
  disconnect: Boolean
  update: ProjectUpdateWithoutNestedLevel1Input
  upsert: ProjectUpsertWithoutNestedLevel1Input
}

input ProjectUpdateWithWhereUniqueWithoutUserInput {
  data: ProjectUpdateWithoutUserInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithoutAwardsInput {
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  entity: StringFieldUpdateOperationsInput
  highlights: ProjectUpdatehighlightsInput
  keywords: ProjectUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  nestedLevel1: NestedProjectLevel1UpdateManyWithoutProjectNestedInput
  roles: ProjectUpdaterolesInput
  startDate: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProjectsNestedInput
}

input ProjectUpdateWithoutNestedLevel1Input {
  awards: AwardUpdateManyWithoutProjectNestedInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  entity: StringFieldUpdateOperationsInput
  highlights: ProjectUpdatehighlightsInput
  keywords: ProjectUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  roles: ProjectUpdaterolesInput
  startDate: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProjectsNestedInput
}

input ProjectUpdateWithoutUserInput {
  awards: AwardUpdateManyWithoutProjectNestedInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  entity: StringFieldUpdateOperationsInput
  highlights: ProjectUpdatehighlightsInput
  keywords: ProjectUpdatekeywordsInput
  name: StringFieldUpdateOperationsInput
  nestedLevel1: NestedProjectLevel1UpdateManyWithoutProjectNestedInput
  roles: ProjectUpdaterolesInput
  startDate: DateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ProjectUpdatehighlightsInput {
  push: [String!]
  set: [String!]
}

input ProjectUpdatekeywordsInput {
  push: [String!]
  set: [String!]
}

input ProjectUpdaterolesInput {
  push: [String!]
  set: [String!]
}

input ProjectUpsertWithWhereUniqueWithoutUserInput {
  create: ProjectCreateWithoutUserInput!
  update: ProjectUpdateWithoutUserInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutAwardsInput {
  create: ProjectCreateWithoutAwardsInput!
  update: ProjectUpdateWithoutAwardsInput!
}

input ProjectUpsertWithoutNestedLevel1Input {
  create: ProjectCreateWithoutNestedLevel1Input!
  update: ProjectUpdateWithoutNestedLevel1Input!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  awards: AwardListRelationFilter
  description: StringFilter
  endDate: DateTimeFilter
  entity: StringFilter
  highlights: StringNullableListFilter
  id: IntFilter
  keywords: StringNullableListFilter
  name: StringFilter
  nestedLevel1: NestedProjectLevel1ListRelationFilter
  roles: StringNullableListFilter
  startDate: DateTimeFilter
  type: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input ProjectWhereUniqueInput {
  id: Int
}

type Publication {
  id: Int!
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
  user: User
  userId: Int!
}

type PublicationAvgAggregate {
  id: Float
  userId: Float
}

input PublicationAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type PublicationCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  publisher: Int!
  releaseDate: Int!
  summary: Int!
  url: Int!
  userId: Int!
}

input PublicationCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  publisher: SortOrder
  releaseDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input PublicationCreateInput {
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
  user: UserCreateNestedOneWithoutPublicationsInput
}

input PublicationCreateManyInput {
  id: Int
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input PublicationCreateManyUserInput {
  id: Int
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
}

input PublicationCreateManyUserInputEnvelope {
  data: [PublicationCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PublicationCreateNestedManyWithoutUserInput {
  connect: [PublicationWhereUniqueInput!]
  connectOrCreate: [PublicationCreateOrConnectWithoutUserInput!]
  create: [PublicationCreateWithoutUserInput!]
  createMany: PublicationCreateManyUserInputEnvelope
}

input PublicationCreateOrConnectWithoutUserInput {
  create: PublicationCreateWithoutUserInput!
  where: PublicationWhereUniqueInput!
}

input PublicationCreateWithoutUserInput {
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
}

type PublicationGroupBy {
  _avg: PublicationAvgAggregate
  _count: PublicationCountAggregate
  _max: PublicationMaxAggregate
  _min: PublicationMinAggregate
  _sum: PublicationSumAggregate
  id: Int!
  name: String!
  publisher: String!
  releaseDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input PublicationListRelationFilter {
  every: PublicationWhereInput
  none: PublicationWhereInput
  some: PublicationWhereInput
}

type PublicationMaxAggregate {
  id: Int
  name: String
  publisher: String
  releaseDate: DateTime
  summary: String
  url: String
  userId: Int
}

input PublicationMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  publisher: SortOrder
  releaseDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

type PublicationMinAggregate {
  id: Int
  name: String
  publisher: String
  releaseDate: DateTime
  summary: String
  url: String
  userId: Int
}

input PublicationMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  publisher: SortOrder
  releaseDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input PublicationOrderByRelationAggregateInput {
  _count: SortOrder
}

input PublicationOrderByWithAggregationInput {
  _avg: PublicationAvgOrderByAggregateInput
  _count: PublicationCountOrderByAggregateInput
  _max: PublicationMaxOrderByAggregateInput
  _min: PublicationMinOrderByAggregateInput
  _sum: PublicationSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  publisher: SortOrder
  releaseDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input PublicationOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  publisher: SortOrder
  releaseDate: SortOrder
  summary: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum PublicationScalarFieldEnum {
  id
  name
  publisher
  releaseDate
  summary
  url
  userId
}

input PublicationScalarWhereInput {
  AND: [PublicationScalarWhereInput!]
  NOT: [PublicationScalarWhereInput!]
  OR: [PublicationScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  publisher: StringFilter
  releaseDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  userId: IntFilter
}

input PublicationScalarWhereWithAggregatesInput {
  AND: [PublicationScalarWhereWithAggregatesInput!]
  NOT: [PublicationScalarWhereWithAggregatesInput!]
  OR: [PublicationScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  publisher: StringWithAggregatesFilter
  releaseDate: DateTimeWithAggregatesFilter
  summary: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type PublicationSumAggregate {
  id: Int
  userId: Int
}

input PublicationSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input PublicationUpdateInput {
  name: StringFieldUpdateOperationsInput
  publisher: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutPublicationsNestedInput
}

input PublicationUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  publisher: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input PublicationUpdateManyWithWhereWithoutUserInput {
  data: PublicationUpdateManyMutationInput!
  where: PublicationScalarWhereInput!
}

input PublicationUpdateManyWithoutUserNestedInput {
  connect: [PublicationWhereUniqueInput!]
  connectOrCreate: [PublicationCreateOrConnectWithoutUserInput!]
  create: [PublicationCreateWithoutUserInput!]
  createMany: PublicationCreateManyUserInputEnvelope
  delete: [PublicationWhereUniqueInput!]
  deleteMany: [PublicationScalarWhereInput!]
  disconnect: [PublicationWhereUniqueInput!]
  set: [PublicationWhereUniqueInput!]
  update: [PublicationUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PublicationUpdateManyWithWhereWithoutUserInput!]
  upsert: [PublicationUpsertWithWhereUniqueWithoutUserInput!]
}

input PublicationUpdateWithWhereUniqueWithoutUserInput {
  data: PublicationUpdateWithoutUserInput!
  where: PublicationWhereUniqueInput!
}

input PublicationUpdateWithoutUserInput {
  name: StringFieldUpdateOperationsInput
  publisher: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input PublicationUpsertWithWhereUniqueWithoutUserInput {
  create: PublicationCreateWithoutUserInput!
  update: PublicationUpdateWithoutUserInput!
  where: PublicationWhereUniqueInput!
}

input PublicationWhereInput {
  AND: [PublicationWhereInput!]
  NOT: [PublicationWhereInput!]
  OR: [PublicationWhereInput!]
  id: IntFilter
  name: StringFilter
  publisher: StringFilter
  releaseDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input PublicationWhereUniqueInput {
  id: Int
}

type Query {
  aggregateAward(cursor: AwardWhereUniqueInput, orderBy: [AwardOrderByWithRelationInput!], skip: Int, take: Int, where: AwardWhereInput): AggregateAward!
  aggregateEducation(cursor: EducationWhereUniqueInput, orderBy: [EducationOrderByWithRelationInput!], skip: Int, take: Int, where: EducationWhereInput): AggregateEducation!
  aggregateInterest(cursor: InterestWhereUniqueInput, orderBy: [InterestOrderByWithRelationInput!], skip: Int, take: Int, where: InterestWhereInput): AggregateInterest!
  aggregateLanguage(cursor: LanguageWhereUniqueInput, orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): AggregateLanguage!
  aggregateLocation(cursor: LocationWhereUniqueInput, orderBy: [LocationOrderByWithRelationInput!], skip: Int, take: Int, where: LocationWhereInput): AggregateLocation!
  aggregateNestedProjectLevel1(cursor: NestedProjectLevel1WhereUniqueInput, orderBy: [NestedProjectLevel1OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel1WhereInput): AggregateNestedProjectLevel1!
  aggregateNestedProjectLevel2(cursor: NestedProjectLevel2WhereUniqueInput, orderBy: [NestedProjectLevel2OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel2WhereInput): AggregateNestedProjectLevel2!
  aggregateProfile(cursor: ProfileWhereUniqueInput, orderBy: [ProfileOrderByWithRelationInput!], skip: Int, take: Int, where: ProfileWhereInput): AggregateProfile!
  aggregateProject(cursor: ProjectWhereUniqueInput, orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
  aggregatePublication(cursor: PublicationWhereUniqueInput, orderBy: [PublicationOrderByWithRelationInput!], skip: Int, take: Int, where: PublicationWhereInput): AggregatePublication!
  aggregateReference(cursor: ReferenceWhereUniqueInput, orderBy: [ReferenceOrderByWithRelationInput!], skip: Int, take: Int, where: ReferenceWhereInput): AggregateReference!
  aggregateSkill(cursor: SkillWhereUniqueInput, orderBy: [SkillOrderByWithRelationInput!], skip: Int, take: Int, where: SkillWhereInput): AggregateSkill!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateVolunteer(cursor: VolunteerWhereUniqueInput, orderBy: [VolunteerOrderByWithRelationInput!], skip: Int, take: Int, where: VolunteerWhereInput): AggregateVolunteer!
  aggregateWork(cursor: WorkWhereUniqueInput, orderBy: [WorkOrderByWithRelationInput!], skip: Int, take: Int, where: WorkWhereInput): AggregateWork!
  award(where: AwardWhereUniqueInput!): Award
  awards(cursor: AwardWhereUniqueInput, distinct: [AwardScalarFieldEnum!], orderBy: [AwardOrderByWithRelationInput!], skip: Int, take: Int, where: AwardWhereInput): [Award!]!
  education(where: EducationWhereUniqueInput!): Education
  educations(cursor: EducationWhereUniqueInput, distinct: [EducationScalarFieldEnum!], orderBy: [EducationOrderByWithRelationInput!], skip: Int, take: Int, where: EducationWhereInput): [Education!]!
  findFirstAward(cursor: AwardWhereUniqueInput, distinct: [AwardScalarFieldEnum!], orderBy: [AwardOrderByWithRelationInput!], skip: Int, take: Int, where: AwardWhereInput): Award
  findFirstEducation(cursor: EducationWhereUniqueInput, distinct: [EducationScalarFieldEnum!], orderBy: [EducationOrderByWithRelationInput!], skip: Int, take: Int, where: EducationWhereInput): Education
  findFirstInterest(cursor: InterestWhereUniqueInput, distinct: [InterestScalarFieldEnum!], orderBy: [InterestOrderByWithRelationInput!], skip: Int, take: Int, where: InterestWhereInput): Interest
  findFirstLanguage(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): Language
  findFirstLocation(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByWithRelationInput!], skip: Int, take: Int, where: LocationWhereInput): Location
  findFirstNestedProjectLevel1(cursor: NestedProjectLevel1WhereUniqueInput, distinct: [NestedProjectLevel1ScalarFieldEnum!], orderBy: [NestedProjectLevel1OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel1WhereInput): NestedProjectLevel1
  findFirstNestedProjectLevel2(cursor: NestedProjectLevel2WhereUniqueInput, distinct: [NestedProjectLevel2ScalarFieldEnum!], orderBy: [NestedProjectLevel2OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel2WhereInput): NestedProjectLevel2
  findFirstProfile(cursor: ProfileWhereUniqueInput, distinct: [ProfileScalarFieldEnum!], orderBy: [ProfileOrderByWithRelationInput!], skip: Int, take: Int, where: ProfileWhereInput): Profile
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstPublication(cursor: PublicationWhereUniqueInput, distinct: [PublicationScalarFieldEnum!], orderBy: [PublicationOrderByWithRelationInput!], skip: Int, take: Int, where: PublicationWhereInput): Publication
  findFirstReference(cursor: ReferenceWhereUniqueInput, distinct: [ReferenceScalarFieldEnum!], orderBy: [ReferenceOrderByWithRelationInput!], skip: Int, take: Int, where: ReferenceWhereInput): Reference
  findFirstSkill(cursor: SkillWhereUniqueInput, distinct: [SkillScalarFieldEnum!], orderBy: [SkillOrderByWithRelationInput!], skip: Int, take: Int, where: SkillWhereInput): Skill
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstVolunteer(cursor: VolunteerWhereUniqueInput, distinct: [VolunteerScalarFieldEnum!], orderBy: [VolunteerOrderByWithRelationInput!], skip: Int, take: Int, where: VolunteerWhereInput): Volunteer
  findFirstWork(cursor: WorkWhereUniqueInput, distinct: [WorkScalarFieldEnum!], orderBy: [WorkOrderByWithRelationInput!], skip: Int, take: Int, where: WorkWhereInput): Work
  groupByAward(by: [AwardScalarFieldEnum!]!, having: AwardScalarWhereWithAggregatesInput, orderBy: [AwardOrderByWithAggregationInput!], skip: Int, take: Int, where: AwardWhereInput): [AwardGroupBy!]!
  groupByEducation(by: [EducationScalarFieldEnum!]!, having: EducationScalarWhereWithAggregatesInput, orderBy: [EducationOrderByWithAggregationInput!], skip: Int, take: Int, where: EducationWhereInput): [EducationGroupBy!]!
  groupByInterest(by: [InterestScalarFieldEnum!]!, having: InterestScalarWhereWithAggregatesInput, orderBy: [InterestOrderByWithAggregationInput!], skip: Int, take: Int, where: InterestWhereInput): [InterestGroupBy!]!
  groupByLanguage(by: [LanguageScalarFieldEnum!]!, having: LanguageScalarWhereWithAggregatesInput, orderBy: [LanguageOrderByWithAggregationInput!], skip: Int, take: Int, where: LanguageWhereInput): [LanguageGroupBy!]!
  groupByLocation(by: [LocationScalarFieldEnum!]!, having: LocationScalarWhereWithAggregatesInput, orderBy: [LocationOrderByWithAggregationInput!], skip: Int, take: Int, where: LocationWhereInput): [LocationGroupBy!]!
  groupByNestedProjectLevel1(by: [NestedProjectLevel1ScalarFieldEnum!]!, having: NestedProjectLevel1ScalarWhereWithAggregatesInput, orderBy: [NestedProjectLevel1OrderByWithAggregationInput!], skip: Int, take: Int, where: NestedProjectLevel1WhereInput): [NestedProjectLevel1GroupBy!]!
  groupByNestedProjectLevel2(by: [NestedProjectLevel2ScalarFieldEnum!]!, having: NestedProjectLevel2ScalarWhereWithAggregatesInput, orderBy: [NestedProjectLevel2OrderByWithAggregationInput!], skip: Int, take: Int, where: NestedProjectLevel2WhereInput): [NestedProjectLevel2GroupBy!]!
  groupByProfile(by: [ProfileScalarFieldEnum!]!, having: ProfileScalarWhereWithAggregatesInput, orderBy: [ProfileOrderByWithAggregationInput!], skip: Int, take: Int, where: ProfileWhereInput): [ProfileGroupBy!]!
  groupByProject(by: [ProjectScalarFieldEnum!]!, having: ProjectScalarWhereWithAggregatesInput, orderBy: [ProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectWhereInput): [ProjectGroupBy!]!
  groupByPublication(by: [PublicationScalarFieldEnum!]!, having: PublicationScalarWhereWithAggregatesInput, orderBy: [PublicationOrderByWithAggregationInput!], skip: Int, take: Int, where: PublicationWhereInput): [PublicationGroupBy!]!
  groupByReference(by: [ReferenceScalarFieldEnum!]!, having: ReferenceScalarWhereWithAggregatesInput, orderBy: [ReferenceOrderByWithAggregationInput!], skip: Int, take: Int, where: ReferenceWhereInput): [ReferenceGroupBy!]!
  groupBySkill(by: [SkillScalarFieldEnum!]!, having: SkillScalarWhereWithAggregatesInput, orderBy: [SkillOrderByWithAggregationInput!], skip: Int, take: Int, where: SkillWhereInput): [SkillGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByVolunteer(by: [VolunteerScalarFieldEnum!]!, having: VolunteerScalarWhereWithAggregatesInput, orderBy: [VolunteerOrderByWithAggregationInput!], skip: Int, take: Int, where: VolunteerWhereInput): [VolunteerGroupBy!]!
  groupByWork(by: [WorkScalarFieldEnum!]!, having: WorkScalarWhereWithAggregatesInput, orderBy: [WorkOrderByWithAggregationInput!], skip: Int, take: Int, where: WorkWhereInput): [WorkGroupBy!]!
  interest(where: InterestWhereUniqueInput!): Interest
  interests(cursor: InterestWhereUniqueInput, distinct: [InterestScalarFieldEnum!], orderBy: [InterestOrderByWithRelationInput!], skip: Int, take: Int, where: InterestWhereInput): [Interest!]!
  language(where: LanguageWhereUniqueInput!): Language
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  location(where: LocationWhereUniqueInput!): Location
  locations(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByWithRelationInput!], skip: Int, take: Int, where: LocationWhereInput): [Location!]!
  nestedProjectLevel1(where: NestedProjectLevel1WhereUniqueInput!): NestedProjectLevel1
  nestedProjectLevel1s(cursor: NestedProjectLevel1WhereUniqueInput, distinct: [NestedProjectLevel1ScalarFieldEnum!], orderBy: [NestedProjectLevel1OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel1WhereInput): [NestedProjectLevel1!]!
  nestedProjectLevel2(where: NestedProjectLevel2WhereUniqueInput!): NestedProjectLevel2
  nestedProjectLevel2s(cursor: NestedProjectLevel2WhereUniqueInput, distinct: [NestedProjectLevel2ScalarFieldEnum!], orderBy: [NestedProjectLevel2OrderByWithRelationInput!], skip: Int, take: Int, where: NestedProjectLevel2WhereInput): [NestedProjectLevel2!]!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(cursor: ProfileWhereUniqueInput, distinct: [ProfileScalarFieldEnum!], orderBy: [ProfileOrderByWithRelationInput!], skip: Int, take: Int, where: ProfileWhereInput): [Profile!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  publication(where: PublicationWhereUniqueInput!): Publication
  publications(cursor: PublicationWhereUniqueInput, distinct: [PublicationScalarFieldEnum!], orderBy: [PublicationOrderByWithRelationInput!], skip: Int, take: Int, where: PublicationWhereInput): [Publication!]!
  reference(where: ReferenceWhereUniqueInput!): Reference
  references(cursor: ReferenceWhereUniqueInput, distinct: [ReferenceScalarFieldEnum!], orderBy: [ReferenceOrderByWithRelationInput!], skip: Int, take: Int, where: ReferenceWhereInput): [Reference!]!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(cursor: SkillWhereUniqueInput, distinct: [SkillScalarFieldEnum!], orderBy: [SkillOrderByWithRelationInput!], skip: Int, take: Int, where: SkillWhereInput): [Skill!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  volunteer(where: VolunteerWhereUniqueInput!): Volunteer
  volunteers(cursor: VolunteerWhereUniqueInput, distinct: [VolunteerScalarFieldEnum!], orderBy: [VolunteerOrderByWithRelationInput!], skip: Int, take: Int, where: VolunteerWhereInput): [Volunteer!]!
  work(where: WorkWhereUniqueInput!): Work
  works(cursor: WorkWhereUniqueInput, distinct: [WorkScalarFieldEnum!], orderBy: [WorkOrderByWithRelationInput!], skip: Int, take: Int, where: WorkWhereInput): [Work!]!
}

enum QueryMode {
  default
  insensitive
}

type Reference {
  id: Int!
  name: String!
  reference: String!
  user: User
  userId: Int!
}

type ReferenceAvgAggregate {
  id: Float
  userId: Float
}

input ReferenceAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type ReferenceCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  reference: Int!
  userId: Int!
}

input ReferenceCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  reference: SortOrder
  userId: SortOrder
}

input ReferenceCreateInput {
  name: String!
  reference: String!
  user: UserCreateNestedOneWithoutReferencesInput
}

input ReferenceCreateManyInput {
  id: Int
  name: String!
  reference: String!
  userId: Int!
}

input ReferenceCreateManyUserInput {
  id: Int
  name: String!
  reference: String!
}

input ReferenceCreateManyUserInputEnvelope {
  data: [ReferenceCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ReferenceCreateNestedManyWithoutUserInput {
  connect: [ReferenceWhereUniqueInput!]
  connectOrCreate: [ReferenceCreateOrConnectWithoutUserInput!]
  create: [ReferenceCreateWithoutUserInput!]
  createMany: ReferenceCreateManyUserInputEnvelope
}

input ReferenceCreateOrConnectWithoutUserInput {
  create: ReferenceCreateWithoutUserInput!
  where: ReferenceWhereUniqueInput!
}

input ReferenceCreateWithoutUserInput {
  name: String!
  reference: String!
}

type ReferenceGroupBy {
  _avg: ReferenceAvgAggregate
  _count: ReferenceCountAggregate
  _max: ReferenceMaxAggregate
  _min: ReferenceMinAggregate
  _sum: ReferenceSumAggregate
  id: Int!
  name: String!
  reference: String!
  userId: Int!
}

input ReferenceListRelationFilter {
  every: ReferenceWhereInput
  none: ReferenceWhereInput
  some: ReferenceWhereInput
}

type ReferenceMaxAggregate {
  id: Int
  name: String
  reference: String
  userId: Int
}

input ReferenceMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  reference: SortOrder
  userId: SortOrder
}

type ReferenceMinAggregate {
  id: Int
  name: String
  reference: String
  userId: Int
}

input ReferenceMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  reference: SortOrder
  userId: SortOrder
}

input ReferenceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ReferenceOrderByWithAggregationInput {
  _avg: ReferenceAvgOrderByAggregateInput
  _count: ReferenceCountOrderByAggregateInput
  _max: ReferenceMaxOrderByAggregateInput
  _min: ReferenceMinOrderByAggregateInput
  _sum: ReferenceSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  reference: SortOrder
  userId: SortOrder
}

input ReferenceOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  reference: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ReferenceScalarFieldEnum {
  id
  name
  reference
  userId
}

input ReferenceScalarWhereInput {
  AND: [ReferenceScalarWhereInput!]
  NOT: [ReferenceScalarWhereInput!]
  OR: [ReferenceScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  reference: StringFilter
  userId: IntFilter
}

input ReferenceScalarWhereWithAggregatesInput {
  AND: [ReferenceScalarWhereWithAggregatesInput!]
  NOT: [ReferenceScalarWhereWithAggregatesInput!]
  OR: [ReferenceScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  reference: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type ReferenceSumAggregate {
  id: Int
  userId: Int
}

input ReferenceSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input ReferenceUpdateInput {
  name: StringFieldUpdateOperationsInput
  reference: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutReferencesNestedInput
}

input ReferenceUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  reference: StringFieldUpdateOperationsInput
}

input ReferenceUpdateManyWithWhereWithoutUserInput {
  data: ReferenceUpdateManyMutationInput!
  where: ReferenceScalarWhereInput!
}

input ReferenceUpdateManyWithoutUserNestedInput {
  connect: [ReferenceWhereUniqueInput!]
  connectOrCreate: [ReferenceCreateOrConnectWithoutUserInput!]
  create: [ReferenceCreateWithoutUserInput!]
  createMany: ReferenceCreateManyUserInputEnvelope
  delete: [ReferenceWhereUniqueInput!]
  deleteMany: [ReferenceScalarWhereInput!]
  disconnect: [ReferenceWhereUniqueInput!]
  set: [ReferenceWhereUniqueInput!]
  update: [ReferenceUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ReferenceUpdateManyWithWhereWithoutUserInput!]
  upsert: [ReferenceUpsertWithWhereUniqueWithoutUserInput!]
}

input ReferenceUpdateWithWhereUniqueWithoutUserInput {
  data: ReferenceUpdateWithoutUserInput!
  where: ReferenceWhereUniqueInput!
}

input ReferenceUpdateWithoutUserInput {
  name: StringFieldUpdateOperationsInput
  reference: StringFieldUpdateOperationsInput
}

input ReferenceUpsertWithWhereUniqueWithoutUserInput {
  create: ReferenceCreateWithoutUserInput!
  update: ReferenceUpdateWithoutUserInput!
  where: ReferenceWhereUniqueInput!
}

input ReferenceWhereInput {
  AND: [ReferenceWhereInput!]
  NOT: [ReferenceWhereInput!]
  OR: [ReferenceWhereInput!]
  id: IntFilter
  name: StringFilter
  reference: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input ReferenceWhereUniqueInput {
  id: Int
}

type Skill {
  category: String!
  id: Int!
  keywords: [String!]!
  level: String!
  user: User
  userId: Int!
}

type SkillAvgAggregate {
  id: Float
  userId: Float
}

input SkillAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type SkillCountAggregate {
  _all: Int!
  category: Int!
  id: Int!
  keywords: Int!
  level: Int!
  userId: Int!
}

input SkillCountOrderByAggregateInput {
  category: SortOrder
  id: SortOrder
  keywords: SortOrder
  level: SortOrder
  userId: SortOrder
}

input SkillCreateInput {
  category: String!
  keywords: SkillCreatekeywordsInput
  level: String!
  user: UserCreateNestedOneWithoutSkillsInput
}

input SkillCreateManyInput {
  category: String!
  id: Int
  keywords: SkillCreatekeywordsInput
  level: String!
  userId: Int!
}

input SkillCreateManyUserInput {
  category: String!
  id: Int
  keywords: SkillCreatekeywordsInput
  level: String!
}

input SkillCreateManyUserInputEnvelope {
  data: [SkillCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SkillCreateNestedManyWithoutUserInput {
  connect: [SkillWhereUniqueInput!]
  connectOrCreate: [SkillCreateOrConnectWithoutUserInput!]
  create: [SkillCreateWithoutUserInput!]
  createMany: SkillCreateManyUserInputEnvelope
}

input SkillCreateOrConnectWithoutUserInput {
  create: SkillCreateWithoutUserInput!
  where: SkillWhereUniqueInput!
}

input SkillCreateWithoutUserInput {
  category: String!
  keywords: SkillCreatekeywordsInput
  level: String!
}

input SkillCreatekeywordsInput {
  set: [String!]!
}

type SkillGroupBy {
  _avg: SkillAvgAggregate
  _count: SkillCountAggregate
  _max: SkillMaxAggregate
  _min: SkillMinAggregate
  _sum: SkillSumAggregate
  category: String!
  id: Int!
  keywords: [String!]
  level: String!
  userId: Int!
}

input SkillListRelationFilter {
  every: SkillWhereInput
  none: SkillWhereInput
  some: SkillWhereInput
}

type SkillMaxAggregate {
  category: String
  id: Int
  level: String
  userId: Int
}

input SkillMaxOrderByAggregateInput {
  category: SortOrder
  id: SortOrder
  level: SortOrder
  userId: SortOrder
}

type SkillMinAggregate {
  category: String
  id: Int
  level: String
  userId: Int
}

input SkillMinOrderByAggregateInput {
  category: SortOrder
  id: SortOrder
  level: SortOrder
  userId: SortOrder
}

input SkillOrderByRelationAggregateInput {
  _count: SortOrder
}

input SkillOrderByWithAggregationInput {
  _avg: SkillAvgOrderByAggregateInput
  _count: SkillCountOrderByAggregateInput
  _max: SkillMaxOrderByAggregateInput
  _min: SkillMinOrderByAggregateInput
  _sum: SkillSumOrderByAggregateInput
  category: SortOrder
  id: SortOrder
  keywords: SortOrder
  level: SortOrder
  userId: SortOrder
}

input SkillOrderByWithRelationInput {
  category: SortOrder
  id: SortOrder
  keywords: SortOrder
  level: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum SkillScalarFieldEnum {
  category
  id
  keywords
  level
  userId
}

input SkillScalarWhereInput {
  AND: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  category: StringFilter
  id: IntFilter
  keywords: StringNullableListFilter
  level: StringFilter
  userId: IntFilter
}

input SkillScalarWhereWithAggregatesInput {
  AND: [SkillScalarWhereWithAggregatesInput!]
  NOT: [SkillScalarWhereWithAggregatesInput!]
  OR: [SkillScalarWhereWithAggregatesInput!]
  category: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  keywords: StringNullableListFilter
  level: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type SkillSumAggregate {
  id: Int
  userId: Int
}

input SkillSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input SkillUpdateInput {
  category: StringFieldUpdateOperationsInput
  keywords: SkillUpdatekeywordsInput
  level: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutSkillsNestedInput
}

input SkillUpdateManyMutationInput {
  category: StringFieldUpdateOperationsInput
  keywords: SkillUpdatekeywordsInput
  level: StringFieldUpdateOperationsInput
}

input SkillUpdateManyWithWhereWithoutUserInput {
  data: SkillUpdateManyMutationInput!
  where: SkillScalarWhereInput!
}

input SkillUpdateManyWithoutUserNestedInput {
  connect: [SkillWhereUniqueInput!]
  connectOrCreate: [SkillCreateOrConnectWithoutUserInput!]
  create: [SkillCreateWithoutUserInput!]
  createMany: SkillCreateManyUserInputEnvelope
  delete: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  disconnect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SkillUpdateManyWithWhereWithoutUserInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutUserInput!]
}

input SkillUpdateWithWhereUniqueWithoutUserInput {
  data: SkillUpdateWithoutUserInput!
  where: SkillWhereUniqueInput!
}

input SkillUpdateWithoutUserInput {
  category: StringFieldUpdateOperationsInput
  keywords: SkillUpdatekeywordsInput
  level: StringFieldUpdateOperationsInput
}

input SkillUpdatekeywordsInput {
  push: [String!]
  set: [String!]
}

input SkillUpsertWithWhereUniqueWithoutUserInput {
  create: SkillCreateWithoutUserInput!
  update: SkillUpdateWithoutUserInput!
  where: SkillWhereUniqueInput!
}

input SkillWhereInput {
  AND: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  category: StringFilter
  id: IntFilter
  keywords: StringNullableListFilter
  level: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input SkillWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  _count: UserCount
  education(cursor: EducationWhereUniqueInput, distinct: [EducationScalarFieldEnum!], orderBy: [EducationOrderByWithRelationInput!], skip: Int, take: Int, where: EducationWhereInput): [Education!]!
  email: String!
  firstName: String!
  id: Int!
  image: String!
  interests(cursor: InterestWhereUniqueInput, distinct: [InterestScalarFieldEnum!], orderBy: [InterestOrderByWithRelationInput!], skip: Int, take: Int, where: InterestWhereInput): [Interest!]!
  label: String!
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  lastName: String!
  location: Location
  phone: String!
  profiles(cursor: ProfileWhereUniqueInput, distinct: [ProfileScalarFieldEnum!], orderBy: [ProfileOrderByWithRelationInput!], skip: Int, take: Int, where: ProfileWhereInput): [Profile!]!
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  publications(cursor: PublicationWhereUniqueInput, distinct: [PublicationScalarFieldEnum!], orderBy: [PublicationOrderByWithRelationInput!], skip: Int, take: Int, where: PublicationWhereInput): [Publication!]!
  references(cursor: ReferenceWhereUniqueInput, distinct: [ReferenceScalarFieldEnum!], orderBy: [ReferenceOrderByWithRelationInput!], skip: Int, take: Int, where: ReferenceWhereInput): [Reference!]!
  skills(cursor: SkillWhereUniqueInput, distinct: [SkillScalarFieldEnum!], orderBy: [SkillOrderByWithRelationInput!], skip: Int, take: Int, where: SkillWhereInput): [Skill!]!
  summary: String!
  volunteer(cursor: VolunteerWhereUniqueInput, distinct: [VolunteerScalarFieldEnum!], orderBy: [VolunteerOrderByWithRelationInput!], skip: Int, take: Int, where: VolunteerWhereInput): [Volunteer!]!
  work(cursor: WorkWhereUniqueInput, distinct: [WorkScalarFieldEnum!], orderBy: [WorkOrderByWithRelationInput!], skip: Int, take: Int, where: WorkWhereInput): [Work!]!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  education: Int!
  interests: Int!
  languages: Int!
  profiles: Int!
  projects: Int!
  publications: Int!
  references: Int!
  skills: Int!
  volunteer: Int!
  work: Int!
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  id: Int!
  image: Int!
  label: Int!
  lastName: Int!
  phone: Int!
  summary: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  label: SortOrder
  lastName: SortOrder
  phone: SortOrder
  summary: SortOrder
}

input UserCreateInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateManyInput {
  email: String!
  firstName: String!
  id: Int
  image: String!
  label: String!
  lastName: String!
  phone: String!
  summary: String!
}

input UserCreateNestedOneWithoutEducationInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEducationInput
  create: UserCreateWithoutEducationInput
}

input UserCreateNestedOneWithoutInterestsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutInterestsInput
  create: UserCreateWithoutInterestsInput
}

input UserCreateNestedOneWithoutLanguagesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLanguagesInput
  create: UserCreateWithoutLanguagesInput
}

input UserCreateNestedOneWithoutLocationInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLocationInput
  create: UserCreateWithoutLocationInput
}

input UserCreateNestedOneWithoutProfilesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProfilesInput
  create: UserCreateWithoutProfilesInput
}

input UserCreateNestedOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
}

input UserCreateNestedOneWithoutPublicationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPublicationsInput
  create: UserCreateWithoutPublicationsInput
}

input UserCreateNestedOneWithoutReferencesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReferencesInput
  create: UserCreateWithoutReferencesInput
}

input UserCreateNestedOneWithoutSkillsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSkillsInput
  create: UserCreateWithoutSkillsInput
}

input UserCreateNestedOneWithoutVolunteerInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVolunteerInput
  create: UserCreateWithoutVolunteerInput
}

input UserCreateNestedOneWithoutWorkInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWorkInput
  create: UserCreateWithoutWorkInput
}

input UserCreateOrConnectWithoutEducationInput {
  create: UserCreateWithoutEducationInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutInterestsInput {
  create: UserCreateWithoutInterestsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLanguagesInput {
  create: UserCreateWithoutLanguagesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLocationInput {
  create: UserCreateWithoutLocationInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProfilesInput {
  create: UserCreateWithoutProfilesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutPublicationsInput {
  create: UserCreateWithoutPublicationsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutReferencesInput {
  create: UserCreateWithoutReferencesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSkillsInput {
  create: UserCreateWithoutSkillsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutVolunteerInput {
  create: UserCreateWithoutVolunteerInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutWorkInput {
  create: UserCreateWithoutWorkInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutEducationInput {
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutInterestsInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutLanguagesInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutLocationInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutProfilesInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutProjectsInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutPublicationsInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutReferencesInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutSkillsInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutVolunteerInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  work: WorkCreateNestedManyWithoutUserInput
}

input UserCreateWithoutWorkInput {
  education: EducationCreateNestedManyWithoutUserInput
  email: String!
  firstName: String!
  image: String!
  interests: InterestCreateNestedManyWithoutUserInput
  label: String!
  languages: LanguageCreateNestedManyWithoutUserInput
  lastName: String!
  location: LocationCreateNestedOneWithoutUserInput
  phone: String!
  profiles: ProfileCreateNestedManyWithoutUserInput
  projects: ProjectCreateNestedManyWithoutUserInput
  publications: PublicationCreateNestedManyWithoutUserInput
  references: ReferenceCreateNestedManyWithoutUserInput
  skills: SkillCreateNestedManyWithoutUserInput
  summary: String!
  volunteer: VolunteerCreateNestedManyWithoutUserInput
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  email: String!
  firstName: String!
  id: Int!
  image: String!
  label: String!
  lastName: String!
  phone: String!
  summary: String!
}

type UserMaxAggregate {
  email: String
  firstName: String
  id: Int
  image: String
  label: String
  lastName: String
  phone: String
  summary: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  label: SortOrder
  lastName: SortOrder
  phone: SortOrder
  summary: SortOrder
}

type UserMinAggregate {
  email: String
  firstName: String
  id: Int
  image: String
  label: String
  lastName: String
  phone: String
  summary: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  label: SortOrder
  lastName: SortOrder
  phone: SortOrder
  summary: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  label: SortOrder
  lastName: SortOrder
  phone: SortOrder
  summary: SortOrder
}

input UserOrderByWithRelationInput {
  education: EducationOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  image: SortOrder
  interests: InterestOrderByRelationAggregateInput
  label: SortOrder
  languages: LanguageOrderByRelationAggregateInput
  lastName: SortOrder
  location: LocationOrderByWithRelationInput
  phone: SortOrder
  profiles: ProfileOrderByRelationAggregateInput
  projects: ProjectOrderByRelationAggregateInput
  publications: PublicationOrderByRelationAggregateInput
  references: ReferenceOrderByRelationAggregateInput
  skills: SkillOrderByRelationAggregateInput
  summary: SortOrder
  volunteer: VolunteerOrderByRelationAggregateInput
  work: WorkOrderByRelationAggregateInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  email
  firstName
  id
  image
  label
  lastName
  phone
  summary
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  image: StringWithAggregatesFilter
  label: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  summary: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutEducationNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEducationInput
  create: UserCreateWithoutEducationInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutEducationInput
  upsert: UserUpsertWithoutEducationInput
}

input UserUpdateOneWithoutInterestsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutInterestsInput
  create: UserCreateWithoutInterestsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutInterestsInput
  upsert: UserUpsertWithoutInterestsInput
}

input UserUpdateOneWithoutLanguagesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLanguagesInput
  create: UserCreateWithoutLanguagesInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutLanguagesInput
  upsert: UserUpsertWithoutLanguagesInput
}

input UserUpdateOneWithoutLocationNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLocationInput
  create: UserCreateWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutLocationInput
  upsert: UserUpsertWithoutLocationInput
}

input UserUpdateOneWithoutProfilesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProfilesInput
  create: UserCreateWithoutProfilesInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutProfilesInput
  upsert: UserUpsertWithoutProfilesInput
}

input UserUpdateOneWithoutProjectsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutProjectsInput
  upsert: UserUpsertWithoutProjectsInput
}

input UserUpdateOneWithoutPublicationsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPublicationsInput
  create: UserCreateWithoutPublicationsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPublicationsInput
  upsert: UserUpsertWithoutPublicationsInput
}

input UserUpdateOneWithoutReferencesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReferencesInput
  create: UserCreateWithoutReferencesInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutReferencesInput
  upsert: UserUpsertWithoutReferencesInput
}

input UserUpdateOneWithoutSkillsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSkillsInput
  create: UserCreateWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutSkillsInput
  upsert: UserUpsertWithoutSkillsInput
}

input UserUpdateOneWithoutVolunteerNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVolunteerInput
  create: UserCreateWithoutVolunteerInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutVolunteerInput
  upsert: UserUpsertWithoutVolunteerInput
}

input UserUpdateOneWithoutWorkNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutWorkInput
  create: UserCreateWithoutWorkInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutWorkInput
  upsert: UserUpsertWithoutWorkInput
}

input UserUpdateWithoutEducationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutInterestsInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutLanguagesInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutLocationInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutProfilesInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutProjectsInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutPublicationsInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutReferencesInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutSkillsInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutVolunteerInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  work: WorkUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutWorkInput {
  education: EducationUpdateManyWithoutUserNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  interests: InterestUpdateManyWithoutUserNestedInput
  label: StringFieldUpdateOperationsInput
  languages: LanguageUpdateManyWithoutUserNestedInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUserNestedInput
  phone: StringFieldUpdateOperationsInput
  profiles: ProfileUpdateManyWithoutUserNestedInput
  projects: ProjectUpdateManyWithoutUserNestedInput
  publications: PublicationUpdateManyWithoutUserNestedInput
  references: ReferenceUpdateManyWithoutUserNestedInput
  skills: SkillUpdateManyWithoutUserNestedInput
  summary: StringFieldUpdateOperationsInput
  volunteer: VolunteerUpdateManyWithoutUserNestedInput
}

input UserUpsertWithoutEducationInput {
  create: UserCreateWithoutEducationInput!
  update: UserUpdateWithoutEducationInput!
}

input UserUpsertWithoutInterestsInput {
  create: UserCreateWithoutInterestsInput!
  update: UserUpdateWithoutInterestsInput!
}

input UserUpsertWithoutLanguagesInput {
  create: UserCreateWithoutLanguagesInput!
  update: UserUpdateWithoutLanguagesInput!
}

input UserUpsertWithoutLocationInput {
  create: UserCreateWithoutLocationInput!
  update: UserUpdateWithoutLocationInput!
}

input UserUpsertWithoutProfilesInput {
  create: UserCreateWithoutProfilesInput!
  update: UserUpdateWithoutProfilesInput!
}

input UserUpsertWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsInput!
}

input UserUpsertWithoutPublicationsInput {
  create: UserCreateWithoutPublicationsInput!
  update: UserUpdateWithoutPublicationsInput!
}

input UserUpsertWithoutReferencesInput {
  create: UserCreateWithoutReferencesInput!
  update: UserUpdateWithoutReferencesInput!
}

input UserUpsertWithoutSkillsInput {
  create: UserCreateWithoutSkillsInput!
  update: UserUpdateWithoutSkillsInput!
}

input UserUpsertWithoutVolunteerInput {
  create: UserCreateWithoutVolunteerInput!
  update: UserUpdateWithoutVolunteerInput!
}

input UserUpsertWithoutWorkInput {
  create: UserCreateWithoutWorkInput!
  update: UserUpdateWithoutWorkInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  education: EducationListRelationFilter
  email: StringFilter
  firstName: StringFilter
  id: IntFilter
  image: StringFilter
  interests: InterestListRelationFilter
  label: StringFilter
  languages: LanguageListRelationFilter
  lastName: StringFilter
  location: LocationRelationFilter
  phone: StringFilter
  profiles: ProfileListRelationFilter
  projects: ProjectListRelationFilter
  publications: PublicationListRelationFilter
  references: ReferenceListRelationFilter
  skills: SkillListRelationFilter
  summary: StringFilter
  volunteer: VolunteerListRelationFilter
  work: WorkListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

type Volunteer {
  endDate: DateTime!
  highlights: [String!]!
  id: Int!
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  user: User
  userId: Int!
}

type VolunteerAvgAggregate {
  id: Float
  userId: Float
}

input VolunteerAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type VolunteerCountAggregate {
  _all: Int!
  endDate: Int!
  highlights: Int!
  id: Int!
  organization: Int!
  position: Int!
  startDate: Int!
  summary: Int!
  url: Int!
  userId: Int!
}

input VolunteerCountOrderByAggregateInput {
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  organization: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input VolunteerCreateInput {
  endDate: DateTime!
  highlights: VolunteerCreatehighlightsInput
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  user: UserCreateNestedOneWithoutVolunteerInput
}

input VolunteerCreateManyInput {
  endDate: DateTime!
  highlights: VolunteerCreatehighlightsInput
  id: Int
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input VolunteerCreateManyUserInput {
  endDate: DateTime!
  highlights: VolunteerCreatehighlightsInput
  id: Int
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
}

input VolunteerCreateManyUserInputEnvelope {
  data: [VolunteerCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input VolunteerCreateNestedManyWithoutUserInput {
  connect: [VolunteerWhereUniqueInput!]
  connectOrCreate: [VolunteerCreateOrConnectWithoutUserInput!]
  create: [VolunteerCreateWithoutUserInput!]
  createMany: VolunteerCreateManyUserInputEnvelope
}

input VolunteerCreateOrConnectWithoutUserInput {
  create: VolunteerCreateWithoutUserInput!
  where: VolunteerWhereUniqueInput!
}

input VolunteerCreateWithoutUserInput {
  endDate: DateTime!
  highlights: VolunteerCreatehighlightsInput
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
}

input VolunteerCreatehighlightsInput {
  set: [String!]!
}

type VolunteerGroupBy {
  _avg: VolunteerAvgAggregate
  _count: VolunteerCountAggregate
  _max: VolunteerMaxAggregate
  _min: VolunteerMinAggregate
  _sum: VolunteerSumAggregate
  endDate: DateTime!
  highlights: [String!]
  id: Int!
  organization: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input VolunteerListRelationFilter {
  every: VolunteerWhereInput
  none: VolunteerWhereInput
  some: VolunteerWhereInput
}

type VolunteerMaxAggregate {
  endDate: DateTime
  id: Int
  organization: String
  position: String
  startDate: DateTime
  summary: String
  url: String
  userId: Int
}

input VolunteerMaxOrderByAggregateInput {
  endDate: SortOrder
  id: SortOrder
  organization: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

type VolunteerMinAggregate {
  endDate: DateTime
  id: Int
  organization: String
  position: String
  startDate: DateTime
  summary: String
  url: String
  userId: Int
}

input VolunteerMinOrderByAggregateInput {
  endDate: SortOrder
  id: SortOrder
  organization: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input VolunteerOrderByRelationAggregateInput {
  _count: SortOrder
}

input VolunteerOrderByWithAggregationInput {
  _avg: VolunteerAvgOrderByAggregateInput
  _count: VolunteerCountOrderByAggregateInput
  _max: VolunteerMaxOrderByAggregateInput
  _min: VolunteerMinOrderByAggregateInput
  _sum: VolunteerSumOrderByAggregateInput
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  organization: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input VolunteerOrderByWithRelationInput {
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  organization: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum VolunteerScalarFieldEnum {
  endDate
  highlights
  id
  organization
  position
  startDate
  summary
  url
  userId
}

input VolunteerScalarWhereInput {
  AND: [VolunteerScalarWhereInput!]
  NOT: [VolunteerScalarWhereInput!]
  OR: [VolunteerScalarWhereInput!]
  endDate: DateTimeFilter
  highlights: StringNullableListFilter
  id: IntFilter
  organization: StringFilter
  position: StringFilter
  startDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  userId: IntFilter
}

input VolunteerScalarWhereWithAggregatesInput {
  AND: [VolunteerScalarWhereWithAggregatesInput!]
  NOT: [VolunteerScalarWhereWithAggregatesInput!]
  OR: [VolunteerScalarWhereWithAggregatesInput!]
  endDate: DateTimeWithAggregatesFilter
  highlights: StringNullableListFilter
  id: IntWithAggregatesFilter
  organization: StringWithAggregatesFilter
  position: StringWithAggregatesFilter
  startDate: DateTimeWithAggregatesFilter
  summary: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type VolunteerSumAggregate {
  id: Int
  userId: Int
}

input VolunteerSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input VolunteerUpdateInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: VolunteerUpdatehighlightsInput
  organization: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutVolunteerNestedInput
}

input VolunteerUpdateManyMutationInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: VolunteerUpdatehighlightsInput
  organization: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input VolunteerUpdateManyWithWhereWithoutUserInput {
  data: VolunteerUpdateManyMutationInput!
  where: VolunteerScalarWhereInput!
}

input VolunteerUpdateManyWithoutUserNestedInput {
  connect: [VolunteerWhereUniqueInput!]
  connectOrCreate: [VolunteerCreateOrConnectWithoutUserInput!]
  create: [VolunteerCreateWithoutUserInput!]
  createMany: VolunteerCreateManyUserInputEnvelope
  delete: [VolunteerWhereUniqueInput!]
  deleteMany: [VolunteerScalarWhereInput!]
  disconnect: [VolunteerWhereUniqueInput!]
  set: [VolunteerWhereUniqueInput!]
  update: [VolunteerUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [VolunteerUpdateManyWithWhereWithoutUserInput!]
  upsert: [VolunteerUpsertWithWhereUniqueWithoutUserInput!]
}

input VolunteerUpdateWithWhereUniqueWithoutUserInput {
  data: VolunteerUpdateWithoutUserInput!
  where: VolunteerWhereUniqueInput!
}

input VolunteerUpdateWithoutUserInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: VolunteerUpdatehighlightsInput
  organization: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input VolunteerUpdatehighlightsInput {
  push: [String!]
  set: [String!]
}

input VolunteerUpsertWithWhereUniqueWithoutUserInput {
  create: VolunteerCreateWithoutUserInput!
  update: VolunteerUpdateWithoutUserInput!
  where: VolunteerWhereUniqueInput!
}

input VolunteerWhereInput {
  AND: [VolunteerWhereInput!]
  NOT: [VolunteerWhereInput!]
  OR: [VolunteerWhereInput!]
  endDate: DateTimeFilter
  highlights: StringNullableListFilter
  id: IntFilter
  organization: StringFilter
  position: StringFilter
  startDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input VolunteerWhereUniqueInput {
  id: Int
}

type Work {
  endDate: DateTime!
  highlights: [String!]!
  id: Int!
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  user: User
  userId: Int!
}

type WorkAvgAggregate {
  id: Float
  userId: Float
}

input WorkAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type WorkCountAggregate {
  _all: Int!
  endDate: Int!
  highlights: Int!
  id: Int!
  name: Int!
  position: Int!
  startDate: Int!
  summary: Int!
  url: Int!
  userId: Int!
}

input WorkCountOrderByAggregateInput {
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input WorkCreateInput {
  endDate: DateTime!
  highlights: WorkCreatehighlightsInput
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  user: UserCreateNestedOneWithoutWorkInput
}

input WorkCreateManyInput {
  endDate: DateTime!
  highlights: WorkCreatehighlightsInput
  id: Int
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input WorkCreateManyUserInput {
  endDate: DateTime!
  highlights: WorkCreatehighlightsInput
  id: Int
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
}

input WorkCreateManyUserInputEnvelope {
  data: [WorkCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input WorkCreateNestedManyWithoutUserInput {
  connect: [WorkWhereUniqueInput!]
  connectOrCreate: [WorkCreateOrConnectWithoutUserInput!]
  create: [WorkCreateWithoutUserInput!]
  createMany: WorkCreateManyUserInputEnvelope
}

input WorkCreateOrConnectWithoutUserInput {
  create: WorkCreateWithoutUserInput!
  where: WorkWhereUniqueInput!
}

input WorkCreateWithoutUserInput {
  endDate: DateTime!
  highlights: WorkCreatehighlightsInput
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
}

input WorkCreatehighlightsInput {
  set: [String!]!
}

type WorkGroupBy {
  _avg: WorkAvgAggregate
  _count: WorkCountAggregate
  _max: WorkMaxAggregate
  _min: WorkMinAggregate
  _sum: WorkSumAggregate
  endDate: DateTime!
  highlights: [String!]
  id: Int!
  name: String!
  position: String!
  startDate: DateTime!
  summary: String!
  url: String!
  userId: Int!
}

input WorkListRelationFilter {
  every: WorkWhereInput
  none: WorkWhereInput
  some: WorkWhereInput
}

type WorkMaxAggregate {
  endDate: DateTime
  id: Int
  name: String
  position: String
  startDate: DateTime
  summary: String
  url: String
  userId: Int
}

input WorkMaxOrderByAggregateInput {
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

type WorkMinAggregate {
  endDate: DateTime
  id: Int
  name: String
  position: String
  startDate: DateTime
  summary: String
  url: String
  userId: Int
}

input WorkMinOrderByAggregateInput {
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input WorkOrderByRelationAggregateInput {
  _count: SortOrder
}

input WorkOrderByWithAggregationInput {
  _avg: WorkAvgOrderByAggregateInput
  _count: WorkCountOrderByAggregateInput
  _max: WorkMaxOrderByAggregateInput
  _min: WorkMinOrderByAggregateInput
  _sum: WorkSumOrderByAggregateInput
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  userId: SortOrder
}

input WorkOrderByWithRelationInput {
  endDate: SortOrder
  highlights: SortOrder
  id: SortOrder
  name: SortOrder
  position: SortOrder
  startDate: SortOrder
  summary: SortOrder
  url: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum WorkScalarFieldEnum {
  endDate
  highlights
  id
  name
  position
  startDate
  summary
  url
  userId
}

input WorkScalarWhereInput {
  AND: [WorkScalarWhereInput!]
  NOT: [WorkScalarWhereInput!]
  OR: [WorkScalarWhereInput!]
  endDate: DateTimeFilter
  highlights: StringNullableListFilter
  id: IntFilter
  name: StringFilter
  position: StringFilter
  startDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  userId: IntFilter
}

input WorkScalarWhereWithAggregatesInput {
  AND: [WorkScalarWhereWithAggregatesInput!]
  NOT: [WorkScalarWhereWithAggregatesInput!]
  OR: [WorkScalarWhereWithAggregatesInput!]
  endDate: DateTimeWithAggregatesFilter
  highlights: StringNullableListFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  position: StringWithAggregatesFilter
  startDate: DateTimeWithAggregatesFilter
  summary: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type WorkSumAggregate {
  id: Int
  userId: Int
}

input WorkSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input WorkUpdateInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: WorkUpdatehighlightsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  user: UserUpdateOneWithoutWorkNestedInput
}

input WorkUpdateManyMutationInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: WorkUpdatehighlightsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input WorkUpdateManyWithWhereWithoutUserInput {
  data: WorkUpdateManyMutationInput!
  where: WorkScalarWhereInput!
}

input WorkUpdateManyWithoutUserNestedInput {
  connect: [WorkWhereUniqueInput!]
  connectOrCreate: [WorkCreateOrConnectWithoutUserInput!]
  create: [WorkCreateWithoutUserInput!]
  createMany: WorkCreateManyUserInputEnvelope
  delete: [WorkWhereUniqueInput!]
  deleteMany: [WorkScalarWhereInput!]
  disconnect: [WorkWhereUniqueInput!]
  set: [WorkWhereUniqueInput!]
  update: [WorkUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [WorkUpdateManyWithWhereWithoutUserInput!]
  upsert: [WorkUpsertWithWhereUniqueWithoutUserInput!]
}

input WorkUpdateWithWhereUniqueWithoutUserInput {
  data: WorkUpdateWithoutUserInput!
  where: WorkWhereUniqueInput!
}

input WorkUpdateWithoutUserInput {
  endDate: DateTimeFieldUpdateOperationsInput
  highlights: WorkUpdatehighlightsInput
  name: StringFieldUpdateOperationsInput
  position: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  summary: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input WorkUpdatehighlightsInput {
  push: [String!]
  set: [String!]
}

input WorkUpsertWithWhereUniqueWithoutUserInput {
  create: WorkCreateWithoutUserInput!
  update: WorkUpdateWithoutUserInput!
  where: WorkWhereUniqueInput!
}

input WorkWhereInput {
  AND: [WorkWhereInput!]
  NOT: [WorkWhereInput!]
  OR: [WorkWhereInput!]
  endDate: DateTimeFilter
  highlights: StringNullableListFilter
  id: IntFilter
  name: StringFilter
  position: StringFilter
  startDate: DateTimeFilter
  summary: StringFilter
  url: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input WorkWhereUniqueInput {
  id: Int
}
